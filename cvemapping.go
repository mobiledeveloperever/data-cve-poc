// Package main implements a tool to fetch, filter, and clone GitHub repositories based on CVE identifiers.
package main

import (
    "bufio"
    "encoding/json"
    "flag"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
    "os"
    "os/exec"
    "path/filepath"
    "regexp"
    "strconv"
    "strings"
    "time"
)

// RepoDetails holds details about a GitHub repository.
type RepoDetails struct {
    CloneURL        string
    Description     string
    StargazersCount int
    CVEName         string
}

// GitHubSearchResponse represents the response from GitHub's search API.
type GitHubSearchResponse struct {
    Items []*GitHubRepository `json:"items"`
}

// GitHubRepository represents a GitHub repository in the search results.
type GitHubRepository struct {
    CloneURL        string `json:"clone_url"`
    Description     string `json:"description"`
    StargazersCount int    `json:"stargazers_count"`
}

// parseArguments parses command-line arguments.
func parseArguments() (*string, *string, *string) {
    token := flag.String("github-token", "", "GitHub Token for authentication")
    page := flag.String("page", "1", "Page number to fetch, or 'all'")
    year := flag.String("year", "", "Year to search for CVEs (e.g., 2024, 2020)")
    flag.Parse()
    return token, page, year
}

// readInputFromStdin reads input from standard input.
func readInputFromStdin() string {
    reader := bufio.NewReader(os.Stdin)
    input, err := reader.ReadString('\n')
    if err != nil {
        log.Fatalf("Error reading input: %v", err)
    }
    return strings.TrimSpace(input)
}

// parsePageNumber parses the page number argument.
func parsePageNumber(page string) int {
    pageNum := 1
    if page != "all" {
        pageNum, _ = strconv.Atoi(page)
    }
    return pageNum
}

// fetchAllRepositories fetches all repositories matching the input query.
func fetchAllRepositories(input, token string, pageNum int, page string) []*GitHubRepository {
    var allRepositories []*GitHubRepository
    for {
        repositories, err := fetchGitHubRepositories(input, token, pageNum)
        if err != nil {
            if strings.Contains(err.Error(), "secondary rate limit") {
                log.Println("Hit secondary rate limit. Pausing for 1 minute.")
                time.Sleep(1 * time.Minute)
                continue
            }
            if strings.Contains(err.Error(), "422") {
                log.Println("Reached the limit of 1000 results for the query.")
                break
            }
            log.Fatalf("Error fetching repositories: %v", err)
        }
        allRepositories = append(allRepositories, repositories.Items...)
        if page != "all" || len(repositories.Items) == 0 {
            break
        }
        pageNum++
        time.Sleep(3 * time.Second) // Prevent hitting rate limits
    }
    return allRepositories
}

// isMarkdownFileWithKeyword checks if the given file is a markdown file and contains specific keywords.
func isMarkdownFileWithKeyword(filePath string, keywords []string) (bool, error) {
    if filepath.Ext(filePath) != ".md" {
        return false, nil
    }

    content, err := ioutil.ReadFile(filePath)
    if err != nil {
        return false, fmt.Errorf("failed to read file %s: %w", filePath, err)
    }

    for _, keyword := range keywords {
        if strings.Contains(strings.ToLower(string(content)), strings.ToLower(keyword)) {
            return true, nil
        }
    }

    return false, nil
}

// fetchGitHubRepositories fetches repositories from GitHub's API based on the query.
func fetchGitHubRepositories(query, token string, page int) (*GitHubSearchResponse, error) {
    client := &http.Client{}
    url := fmt.Sprintf(`https://api.github.com/search/repositories?q=%s&sort=updated&order=desc&page=%d`, query, page)

    req, err := http.NewRequest("GET", url, nil)
    if err != nil {
        return nil, err
    }
    req.Header.Set("Authorization", "token "+token)

    resp, err := client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        body, _ := ioutil.ReadAll(resp.Body)
        return nil, fmt.Errorf("failed to fetch repositories, status: %d, response: %s", resp.StatusCode, string(body))
    }

    var searchResponse GitHubSearchResponse
    if err := json.NewDecoder(resp.Body).Decode(&searchResponse); err != nil {
        return nil, err
    }

    return &searchResponse, nil
}

// filterRepositories filters the repositories based on CVE naming and stargazers count.
func filterRepositories(repositories []*GitHubRepository, year string) []RepoDetails {
    var repositoriesToClone []RepoDetails
    cveRegex := regexp.MustCompile(fmt.Sprintf(`(?i)cve-%s-\d+`, year))
    cveMap := make(map[string]RepoDetails)

    for _, repo := range repositories {
        cloneURL := repo.CloneURL
        description := repo.Description
        stargazersCount := repo.StargazersCount

        matches := cveRegex.FindAllString(cloneURL+description, -1)
        if len(matches) == 0 {
            continue
        }

        uniqueMatches := uniqueStrings(matches)
        if len(uniqueMatches) > 1 {
            log.Printf("[SKIPPING] [%d] %s", stargazersCount, cloneURL)
            continue
        }

        cveName := strings.ToUpper(uniqueMatches[0])
        if existingRepo, exists := cveMap[cveName]; exists {
            if stargazersCount > existingRepo.StargazersCount {
                log.Printf("[REPLACING DUPLICATE] [%d] %s (Replaces %s)", stargazersCount, cloneURL, existingRepo.CloneURL)
                cveMap[cveName] = RepoDetails{
                    CloneURL:        cloneURL,
                    Description:     description,
                    StargazersCount: stargazersCount,
                    CVEName:         cveName,
                }
            } else {
                log.Printf("[SKIPPING] [%d] %s (Already have better clone)", stargazersCount, cloneURL)
            }
        } else {
            cveMap[cveName] = RepoDetails{
                CloneURL:        cloneURL,
                Description:     description,
                StargazersCount: stargazersCount,
                CVEName:         cveName,
            }
        }
    }

    for _, repo := range cveMap {
        repositoriesToClone = append(repositoriesToClone, repo)
    }

    return repositoriesToClone
}

// cloneRepository clones the repository and cleans it up.
func cloneRepository(cloneURL, cveName string, stargazersCount int, year string) error {
    cloneDirectory := fmt.Sprintf("%s/%s", year, cveName)
    if _, err := os.Stat(cloneDirectory); !os.IsNotExist(err) {
        fmt.Printf("[ALREADY EXISTS] [%d] %s into %s\n", stargazersCount, cloneURL, cloneDirectory)
        return nil
    }

    // Clone the repository with depth 1 to save bandwidth and space
    cmd := exec.Command("git", "clone", "--depth", "1", cloneURL, cloneDirectory)
    err := cmd.Run()
    if err != nil {
        return fmt.Errorf("failed to clone repository: %w", err)
    }

    fmt.Printf("[CLONED] [%d] %s into %s\n", stargazersCount, cloneURL, cloneDirectory)
    return cleanClonedRepository(cloneDirectory)
}

// cleanClonedRepository removes unnecessary files and directories from the cloned repository.
func cleanClonedRepository(cloneDirectory string) error {
    // List of items to remove from the cloned repository
    itemsToRemove := []string{".git", ".github", ".gitignore", ".gitattributes", "LICENSE"}

    // Keywords to exclude markdown files
    excludedKeywords := []string{"donation", "sponsor"}

    err := filepath.Walk(cloneDirectory, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }

        // Check markdown files for specific keywords
        if !info.IsDir() {
            isExcluded, err := isMarkdownFileWithKeyword(path, excludedKeywords)
            if err != nil {
                log.Printf("Error checking file %s: %v", path, err)
                return nil
            }
            if isExcluded {
                if err := os.Remove(path); err != nil {
                    return fmt.Errorf("failed to remove file %s: %w", path, err)
                }
                log.Printf("[REMOVED MD FILE WITH KEYWORD] %s", path)
                return nil
            }
        }

        // Remove specified items
        for _, item := range itemsToRemove {
            if strings.HasSuffix(path, item) {
                if err := os.RemoveAll(path); err != nil {
                    return fmt.Errorf("failed to remove %s: %w", path, err)
                }
                log.Printf("[REMOVED %s] from %s\n", item, cloneDirectory)
                return nil
            }
        }

        return nil
    })

    if err != nil {
        return fmt.Errorf("failed to walk directory %s: %w", cloneDirectory, err)
    }

    // Get the size and file count of the cleaned repository
    dirSize, fileCount, err := getDirSizeAndFileCount(cloneDirectory)
    if err != nil {
        return fmt.Errorf("failed to check directory size or file count: %w", err)
    }

    // Delete the directory if it's too large or has too many files
    if dirSize > 1*1024*1024 || fileCount > 5 {
        if err := os.RemoveAll(cloneDirectory); err != nil {
            return fmt.Errorf("failed to delete directory: %w", err)
        }
        log.Printf("[DELETED] %s because size was %d bytes or had %d files\n", cloneDirectory, dirSize, fileCount)
    } else {
        log.Printf("[KEPT] %s with size %d bytes and %d files\n", cloneDirectory, dirSize, fileCount)
    }

    return nil
}

// getDirSizeAndFileCount calculates the total size and number of files in a directory.
func getDirSizeAndFileCount(path string) (int64, int, error) {
    var totalSize int64
    var fileCount int

    err := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        if !info.IsDir() {
            totalSize += info.Size()
            fileCount++
        }
        return nil
    })

    if err != nil {
        return 0, 0, err
    }

    return totalSize, fileCount, nil
}

// uniqueStrings removes duplicates from a slice of strings.
func uniqueStrings(input []string) []string {
    keys := make(map[string]bool)
    list := []string{}

    for _, entry := range input {
        if _, exists := keys[entry]; !exists {
            keys[entry] = true
            list = append(list, entry)
        }
    }

    return list
}

// main function ties all the sub-functions together.
func main() {
    // Parse command-line arguments.
    token, page, year := parseArguments()

    // Check if GitHub token is provided.
    if *token == "" {
        log.Fatal("GitHub token is required")
    }

    // Read input query from stdin.
    inputQuery := readInputFromStdin()

    // Parse page number for pagination.
    pageNumber := parsePageNumber(*page)

    // Fetch all repositories based on the input query.
    allRepositories := fetchAllRepositories(inputQuery, *token, pageNumber, *page)

    // Filter repositories to get the ones we want to clone.
    repositoriesToClone := filterRepositories(allRepositories, *year)

    // Clone and clean each repository.
    for _, repo := range repositoriesToClone {
        if err := cloneRepository(repo.CloneURL, repo.CVEName, repo.StargazersCount, *year); err != nil {
            log.Printf("Error cloning repo %s: %v", repo.CloneURL, err)
        }
    }
}
