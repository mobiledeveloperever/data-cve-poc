package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"
)

type RepoDetails struct {
	CloneURL        string
	Description     string
	StargazersCount int
	CVEName         string
}

type GitHubSearchResponse struct {
	Items []*GitHubRepository `json:"items"`
}

type GitHubRepository struct {
	CloneURL        string `json:"clone_url"`
	Description     string `json:"description"`
	StargazersCount int    `json:"stargazers_count"`
}

func main() {
	token, page, year := parseArguments()

	if *token == "" {
		log.Fatal("GitHub token is required")
	}

	input := readInputFromStdin()
	pageNum := parsePageNumber(*page)

	allRepos := fetchAllRepositories(input, *token, pageNum, *page)
	reposToClone := filterRepositories(allRepos, *year)

	for _, repo := range reposToClone {
		if err := cloneRepository(repo.CloneURL, repo.CVEName, repo.StargazersCount, *year); err != nil {
			log.Printf("Error cloning repo %s: %v", repo.CloneURL, err)
		}
	}
}

// 解析命令行参数
func parseArguments() (*string, *string, *string) {
	token := flag.String("github-token", "", "GitHub Token for authentication")
	page := flag.String("page", "1", "Page number to fetch, or 'all'")
	year := flag.String("year", "", "Year to search for CVEs (e.g., 2024, 2020)")
	flag.Parse()
	return token, page, year
}

// 从标准输入读取输入
func readInputFromStdin() string {
	reader := bufio.NewReader(os.Stdin)
	input, err := reader.ReadString('\n')
	if err != nil {
		log.Fatalf("Error reading input: %v", err)
	}
	return strings.TrimSpace(input)
}

// 解析页码参数
func parsePageNumber(page string) int {
	pageNum := 1
	if page != "all" {
		pageNum, _ = strconv.Atoi(page)
	}
	return pageNum
}

// 获取所有的仓库数据
func fetchAllRepositories(input, token string, pageNum int, page string) []*GitHubRepository {
	var allRepos []*GitHubRepository
	for {
		repos, err := fetchGitHubRepositories(input, token, pageNum)
		if err != nil {
			if strings.Contains(err.Error(), "422") {
				log.Println("Reached the limit of 1000 results for the query.")
				break
			}
			log.Fatalf("Error fetching repositories: %v", err)
		}
		allRepos = append(allRepos, repos.Items...)
		if page != "all" || len(repos.Items) == 0 {
			break
		}
		pageNum++
		time.Sleep(3 * time.Second) // 防止达到速率限制
	}
	return allRepos
}

// 从 GitHub API 获取仓库
func fetchGitHubRepositories(query, token string, page int) (*GitHubSearchResponse, error) {
	client := &http.Client{}
	url := fmt.Sprintf(`https://api.github.com/search/repositories?q=%s&sort=updated&order=desc&page=%d`, query, page)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Authorization", "token "+token)

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("failed to fetch repositories, status: %d, response: %s", resp.StatusCode, string(body))
	}

	var searchResponse GitHubSearchResponse
	if err := json.NewDecoder(resp.Body).Decode(&searchResponse); err != nil {
		return nil, err
	}

	return &searchResponse, nil
}

// 过滤仓库数据
func filterRepositories(repos []*GitHubRepository, year string) []RepoDetails {
	var reposToClone []RepoDetails
	cveRegex := regexp.MustCompile(fmt.Sprintf(`(?i)cve-%s-\d+`, year))
	cveMap := make(map[string]RepoDetails)

	for _, repo := range repos {
		cloneURL := repo.CloneURL
		description := repo.Description
		stargazersCount := repo.StargazersCount

		matches := cveRegex.FindAllString(cloneURL+description, -1)
		if len(matches) == 0 {
			continue
		}

		uniqueMatches := uniqueStrings(matches)
		if len(uniqueMatches) > 1 {
			log.Printf("[SKIPPING] [%d] %s", stargazersCount, cloneURL)
			continue
		}

		cveName := strings.ToUpper(uniqueMatches[0])
		if existingRepo, exists := cveMap[cveName]; exists {
			if stargazersCount > existingRepo.StargazersCount {
				log.Printf("[SKIPPING DUPLICATE] [%d] %s (Duplicate of %s)", stargazersCount, cloneURL, existingRepo.CloneURL)
				cveMap[cveName] = RepoDetails{CloneURL: cloneURL, Description: description, StargazersCount: stargazersCount, CVEName: cveName}
			} else {
				log.Printf("[SKIPPING] [%d] %s (Already cloned: %s)", stargazersCount, cloneURL, existingRepo.CloneURL)
			}
		} else {
			cveMap[cveName] = RepoDetails{CloneURL: cloneURL, Description: description, StargazersCount: stargazersCount, CVEName: cveName}
		}
	}

	for _, repo := range cveMap {
		reposToClone = append(reposToClone, repo)
	}

	return reposToClone
}

// 克隆仓库
func cloneRepository(cloneURL, cveName string, stargazersCount int, year string) error {
	cloneDir := fmt.Sprintf("%s/%s", year, cveName)
	if _, err := os.Stat(cloneDir); !os.IsNotExist(err) {
		fmt.Printf("[ALREADY EXISTS] [%d] %s into %s\n", stargazersCount, cloneURL, cloneDir)
		return nil
	}

	cmd := exec.Command("git", "clone", "--depth", "1", cloneURL, cloneDir)
	err := cmd.Run()
	if err != nil {
		return fmt.Errorf("failed to clone repository: %w", err)
	}

	fmt.Printf("[CLONED] [%d] %s into %s\n", stargazersCount, cloneURL, cloneDir)
	return cleanClonedRepository(cloneDir)
}

// 清理克隆的仓库
func cleanClonedRepository(cloneDir string) error {
	itemsToRemove := []string{ ".git", ".github", ".gitignore", ".gitattributes", "LICENSE" }
	for _, item := range itemsToRemove {
		itemPath := filepath.Join(cloneDir, item)
		if err := os.RemoveAll(itemPath); err != nil {
			return fmt.Errorf("failed to remove %s: %w", item, err)
		}
		fmt.Printf("[REMOVED %s] from %s\n", item, cloneDir)
	}

	dirSize, fileCount, err := getDirSizeAndFileCount(cloneDir)
	if err != nil {
		return fmt.Errorf("failed to check directory size or file count: %w", err)
	}

	if dirSize > 1*1024*1024 || fileCount > 5 {
		if err := os.RemoveAll(cloneDir); err != nil {
			return fmt.Errorf("failed to delete directory: %w", err)
		}
		fmt.Printf("[DELETED] %s because size was %d bytes or had %d files\n", cloneDir, dirSize, fileCount)
	} else {
		fmt.Printf("[KEPT] %s with size %d bytes and %d files\n", cloneDir, dirSize, fileCount)
	}

	return nil
}

// 获取目录大小和文件数量
func getDirSizeAndFileCount(path string) (int64, int, error) {
	var totalSize int64
	var fileCount int

	err := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			totalSize += info.Size()
			fileCount++
		}
		return nil
	})

	if err != nil {
		return 0, 0, err
	}

	return totalSize, fileCount, nil
}

// 去除重复的字符串
func uniqueStrings(input []string) []string {
	keys := make(map[string]bool)
	list := []string{}

	for _, entry := range input {
		if _, exists := keys[entry]; !exists {
			keys[entry] = true
			list = append(list, entry)
		}
	}

	return list
}