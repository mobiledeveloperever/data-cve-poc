package main

import (
	"bytes"
	"context"
	"fmt"
	"github.com/moby/buildkit/client/llb"
	"github.com/moby/buildkit/frontend/dockerfile/instructions"
	"github.com/moby/buildkit/frontend/dockerfile/parser"
	"github.com/moby/buildkit/frontend/dockerui"
	"github.com/moby/buildkit/solver/pb"
	"github.com/pkg/errors"
	"io"
	"log"

	"strings"
	"time"

	"github.com/moby/buildkit/frontend/gateway/client"
	"github.com/moby/buildkit/frontend/gateway/grpcclient"
	"github.com/moby/buildkit/util/appcontext"
)

type nopCloser struct {
	io.Writer
}

func (n *nopCloser) Close() error {
	return nil
}

type testPrompt struct {
	ctx    context.Context
	output *bytes.Buffer
	input  io.Writer
	prompt string
	pos    int
}

func newTestPrompt(ctx context.Context, input io.Writer, output *bytes.Buffer) *testPrompt {
	return &testPrompt{
		ctx:    ctx,
		input:  input,
		output: output,
		prompt: "% ",
	}
}

func (p *testPrompt) String() string { return p.prompt }

func (p *testPrompt) SendExit(status int) {
	p.input.Write([]byte(fmt.Sprintf("exit %d\n", status)))
}

func (p *testPrompt) Send(cmd string) {
	p.input.Write([]byte(cmd + "\n"))
	p.wait(p.prompt)
}

func (p *testPrompt) SendExpect(cmd, expected string) {
	for {
		p.input.Write([]byte(cmd + "\n"))
		response := p.wait(p.prompt)
		if strings.Contains(response, expected) {
			return
		}
	}
}

func (p *testPrompt) wait(msg string) string {
	for {
		newOutput := p.output.String()[p.pos:]
		if strings.Contains(newOutput, msg) {
			p.pos += len(newOutput)
			return newOutput
		}
		select {
		case <-p.ctx.Done():
			log.Printf("Output at timeout: %s", p.output.String())
			log.Fatalf("Timeout waiting for %q", msg)
		case <-time.After(100 * time.Millisecond):
		}
	}
}

func main() {

	inputR, inputW := io.Pipe()
	output := bytes.NewBuffer(nil)

	b := func(ctx context.Context, c client.Client) (*client.Result, error) {
		ctx, timeout := context.WithTimeout(ctx, 60*time.Second)
		defer timeout()

		bc, err := dockerui.NewClient(c)
		if err != nil {
			return nil, err
		}

		src, err := bc.ReadEntrypoint(ctx, "Dockerfile")
		if err != nil {
			return nil, err
		}

		dockerfile, err := parser.Parse(bytes.NewReader(src.Data))
		if err != nil {
			return nil, err
		}

		prompt := newTestPrompt(ctx, inputW, output)
		var pid client.ContainerProcess
		for _, n := range dockerfile.AST.Children {
			command, err := instructions.ParseInstruction(n)
			if err != nil {
				return nil, err
			}

			switch cmd := command.(type) {
			case *instructions.Stage:
				st := llb.Image(cmd.BaseName)
				securityMode := pb.SecurityMode_INSECURE
				if cmd.Name != "" {
					securityMode = pb.SecurityMode(pb.SecurityMode_value[strings.ToUpper(cmd.Name)])
				}

				def, err := st.Marshal(ctx)
				if err != nil {
					return nil, err
				}

				r, err := c.Solve(ctx, client.SolveRequest{
					Definition: def.ToPB(),
				})
				if err != nil {
					return nil, err
				}

				ctr, err := c.NewContainer(ctx, client.NewContainerRequest{
					Mounts: []client.Mount{{
						Dest:      "/",
						MountType: pb.MountType_BIND,
						Ref:       r.Ref,
					}},
					//NetMode: pb.NetMode_HOST,
				})

				pid, err = ctr.Start(ctx, client.StartRequest{
					Args:         []string{"sh"},
					Tty:          true,
					Stdin:        inputR,
					Stdout:       &nopCloser{output},
					Stderr:       &nopCloser{output},
					Env:          []string{fmt.Sprintf("PS1=%s", prompt.String())},
					SecurityMode: securityMode,
				})

				if err != nil {
					return nil, err
				}

			case *instructions.RunCommand:
				prompt.Send(strings.Join(cmd.ShellDependantCmdLine.CmdLine, " "))
			}
		}
		prompt.SendExit(99)
		err = pid.Wait()

		return nil, errors.Wrap(err, fmt.Sprintln(output))
	}

	if err := grpcclient.RunFromEnvironment(appcontext.Context(), b); err != nil {
		log.Fatal(err)
	}

}
